// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_APP_WEBMANAGER_H_
#define FLATBUFFERS_GENERATED_APP_WEBMANAGER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

namespace webmanager {

struct AccessPoint;
struct AccessPointBuilder;

struct RequestNetworkInformation;
struct RequestNetworkInformationBuilder;

struct ResponseNetworkInformation;
struct ResponseNetworkInformationBuilder;

struct RequestWifiConnect;
struct RequestWifiConnectBuilder;

struct ResponseWifiConnectSuccessful;
struct ResponseWifiConnectSuccessfulBuilder;

struct ResponseWifiConnectFailed;
struct ResponseWifiConnectFailedBuilder;

struct RequestWifiDisconnect;
struct RequestWifiDisconnectBuilder;

struct ResponseWifiDisconnect;
struct ResponseWifiDisconnectBuilder;

struct Mac6;

struct RequestRestart;
struct RequestRestartBuilder;

struct RequestSystemData;
struct RequestSystemDataBuilder;

struct PartitionInfo;
struct PartitionInfoBuilder;

struct ResponseSystemData;
struct ResponseSystemDataBuilder;

struct StringSetting;
struct StringSettingBuilder;

struct IntegerSetting;
struct IntegerSettingBuilder;

struct BooleanSetting;
struct BooleanSettingBuilder;

struct EnumSetting;
struct EnumSettingBuilder;

struct SettingWrapper;
struct SettingWrapperBuilder;

struct RequestGetUserSettings;
struct RequestGetUserSettingsBuilder;

struct ResponseGetUserSettings;
struct ResponseGetUserSettingsBuilder;

struct RequestSetUserSettings;
struct RequestSetUserSettingsBuilder;

struct ResponseSetUserSettings;
struct ResponseSetUserSettingsBuilder;

struct RequestTimeseries;
struct RequestTimeseriesBuilder;

struct ResponseTimeseriesDummy;
struct ResponseTimeseriesDummyBuilder;

}  // namespace webmanager

namespace websensact {

struct MessagePayload;

struct CommandMessage;
struct CommandMessageBuilder;

}  // namespace websensact

namespace webmanager {

struct RequestOpenDoor;
struct RequestOpenDoorBuilder;

struct RequestEnrollNewFinger;
struct RequestEnrollNewFingerBuilder;

struct ResponseEnrollNewFinger;
struct ResponseEnrollNewFingerBuilder;

struct NotifyEnrollNewFinger;
struct NotifyEnrollNewFingerBuilder;

struct NotifyFingerDetected;
struct NotifyFingerDetectedBuilder;

struct RequestDeleteFinger;
struct RequestDeleteFingerBuilder;

struct ResponseDeleteFinger;
struct ResponseDeleteFingerBuilder;

struct RequestDeleteAllFingers;
struct RequestDeleteAllFingersBuilder;

struct ResponseDeleteAllFingers;
struct ResponseDeleteAllFingersBuilder;

struct RequestCancelInstruction;
struct RequestCancelInstructionBuilder;

struct ResponseCancelInstruction;
struct ResponseCancelInstructionBuilder;

struct RequestRenameFinger;
struct RequestRenameFingerBuilder;

struct ResponseRenameFinger;
struct ResponseRenameFingerBuilder;

struct RequestFingerprintSensorInfo;
struct RequestFingerprintSensorInfoBuilder;

struct ResponseFingerprintSensorInfo;
struct ResponseFingerprintSensorInfoBuilder;

struct RequestFingers;
struct RequestFingersBuilder;

struct Finger;
struct FingerBuilder;

struct ResponseFingers;
struct ResponseFingersBuilder;

struct CanData;

struct NotifyCanMessage;
struct NotifyCanMessageBuilder;

struct RequestJournal;
struct RequestJournalBuilder;

struct JournalItem;
struct JournalItemBuilder;

struct ResponseJournal;
struct ResponseJournalBuilder;

struct NotifyLiveLogItem;
struct NotifyLiveLogItemBuilder;

struct RequestWrapper;
struct RequestWrapperBuilder;

struct ResponseWrapper;
struct ResponseWrapperBuilder;

enum Setting : uint8_t {
  Setting_NONE = 0,
  Setting_StringSetting = 1,
  Setting_IntegerSetting = 2,
  Setting_BooleanSetting = 3,
  Setting_EnumSetting = 4,
  Setting_MIN = Setting_NONE,
  Setting_MAX = Setting_EnumSetting
};

inline const Setting (&EnumValuesSetting())[5] {
  static const Setting values[] = {
    Setting_NONE,
    Setting_StringSetting,
    Setting_IntegerSetting,
    Setting_BooleanSetting,
    Setting_EnumSetting
  };
  return values;
}

inline const char * const *EnumNamesSetting() {
  static const char * const names[6] = {
    "NONE",
    "StringSetting",
    "IntegerSetting",
    "BooleanSetting",
    "EnumSetting",
    nullptr
  };
  return names;
}

inline const char *EnumNameSetting(Setting e) {
  if (::flatbuffers::IsOutRange(e, Setting_NONE, Setting_EnumSetting)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSetting()[index];
}

template<typename T> struct SettingTraits {
  static const Setting enum_value = Setting_NONE;
};

template<> struct SettingTraits<webmanager::StringSetting> {
  static const Setting enum_value = Setting_StringSetting;
};

template<> struct SettingTraits<webmanager::IntegerSetting> {
  static const Setting enum_value = Setting_IntegerSetting;
};

template<> struct SettingTraits<webmanager::BooleanSetting> {
  static const Setting enum_value = Setting_BooleanSetting;
};

template<> struct SettingTraits<webmanager::EnumSetting> {
  static const Setting enum_value = Setting_EnumSetting;
};

bool VerifySetting(::flatbuffers::Verifier &verifier, const void *obj, Setting type);
bool VerifySettingVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum TimeGranularity : int8_t {
  TimeGranularity_TEN_SECONDS = 0,
  TimeGranularity_ONE_MINUTE = 1,
  TimeGranularity_ONE_HOUR = 2,
  TimeGranularity_ONE_DAY = 3,
  TimeGranularity_MIN = TimeGranularity_TEN_SECONDS,
  TimeGranularity_MAX = TimeGranularity_ONE_DAY
};

inline const TimeGranularity (&EnumValuesTimeGranularity())[4] {
  static const TimeGranularity values[] = {
    TimeGranularity_TEN_SECONDS,
    TimeGranularity_ONE_MINUTE,
    TimeGranularity_ONE_HOUR,
    TimeGranularity_ONE_DAY
  };
  return values;
}

inline const char * const *EnumNamesTimeGranularity() {
  static const char * const names[5] = {
    "TEN_SECONDS",
    "ONE_MINUTE",
    "ONE_HOUR",
    "ONE_DAY",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeGranularity(TimeGranularity e) {
  if (::flatbuffers::IsOutRange(e, TimeGranularity_TEN_SECONDS, TimeGranularity_ONE_DAY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeGranularity()[index];
}

}  // namespace webmanager

enum ApplicationId : uint16_t {
  ApplicationId_ApplicationId_MASTER = 0,
  ApplicationId_ApplicationId_NO_APPLICATION = 65535,
  ApplicationId_MIN = ApplicationId_ApplicationId_MASTER,
  ApplicationId_MAX = ApplicationId_ApplicationId_NO_APPLICATION
};

inline const ApplicationId (&EnumValuesApplicationId())[2] {
  static const ApplicationId values[] = {
    ApplicationId_ApplicationId_MASTER,
    ApplicationId_ApplicationId_NO_APPLICATION
  };
  return values;
}

inline const char *EnumNameApplicationId(ApplicationId e) {
  switch (e) {
    case ApplicationId_ApplicationId_MASTER: return "ApplicationId_MASTER";
    case ApplicationId_ApplicationId_NO_APPLICATION: return "ApplicationId_NO_APPLICATION";
    default: return "";
  }
}

enum Command : int8_t {
  Command_NOP = 0,
  Command_MIN = Command_NOP,
  Command_MAX = Command_NOP
};

inline const Command (&EnumValuesCommand())[1] {
  static const Command values[] = {
    Command_NOP
  };
  return values;
}

inline const char * const *EnumNamesCommand() {
  static const char * const names[2] = {
    "NOP",
    nullptr
  };
  return names;
}

inline const char *EnumNameCommand(Command e) {
  if (::flatbuffers::IsOutRange(e, Command_NOP, Command_NOP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCommand()[index];
}

namespace webmanager {

enum Responses : uint8_t {
  Responses_NONE = 0,
  Responses_NotifyCanMessage = 1,
  Responses_NotifyLiveLogItem = 2,
  Responses_ResponseNetworkInformation = 3,
  Responses_ResponseWifiConnectSuccessful = 4,
  Responses_ResponseWifiConnectFailed = 5,
  Responses_ResponseWifiDisconnect = 6,
  Responses_ResponseSystemData = 7,
  Responses_ResponseJournal = 8,
  Responses_ResponseGetUserSettings = 9,
  Responses_ResponseSetUserSettings = 10,
  Responses_ResponseTimeseriesDummy = 11,
  Responses_ResponseEnrollNewFinger = 12,
  Responses_NotifyEnrollNewFinger = 13,
  Responses_NotifyFingerDetected = 14,
  Responses_ResponseDeleteFinger = 15,
  Responses_ResponseRenameFinger = 16,
  Responses_ResponseFingerprintSensorInfo = 17,
  Responses_ResponseDeleteAllFingers = 18,
  Responses_ResponseFingers = 19,
  Responses_ResponseCancelInstruction = 20,
  Responses_MIN = Responses_NONE,
  Responses_MAX = Responses_ResponseCancelInstruction
};

inline const Responses (&EnumValuesResponses())[21] {
  static const Responses values[] = {
    Responses_NONE,
    Responses_NotifyCanMessage,
    Responses_NotifyLiveLogItem,
    Responses_ResponseNetworkInformation,
    Responses_ResponseWifiConnectSuccessful,
    Responses_ResponseWifiConnectFailed,
    Responses_ResponseWifiDisconnect,
    Responses_ResponseSystemData,
    Responses_ResponseJournal,
    Responses_ResponseGetUserSettings,
    Responses_ResponseSetUserSettings,
    Responses_ResponseTimeseriesDummy,
    Responses_ResponseEnrollNewFinger,
    Responses_NotifyEnrollNewFinger,
    Responses_NotifyFingerDetected,
    Responses_ResponseDeleteFinger,
    Responses_ResponseRenameFinger,
    Responses_ResponseFingerprintSensorInfo,
    Responses_ResponseDeleteAllFingers,
    Responses_ResponseFingers,
    Responses_ResponseCancelInstruction
  };
  return values;
}

inline const char * const *EnumNamesResponses() {
  static const char * const names[22] = {
    "NONE",
    "NotifyCanMessage",
    "NotifyLiveLogItem",
    "ResponseNetworkInformation",
    "ResponseWifiConnectSuccessful",
    "ResponseWifiConnectFailed",
    "ResponseWifiDisconnect",
    "ResponseSystemData",
    "ResponseJournal",
    "ResponseGetUserSettings",
    "ResponseSetUserSettings",
    "ResponseTimeseriesDummy",
    "ResponseEnrollNewFinger",
    "NotifyEnrollNewFinger",
    "NotifyFingerDetected",
    "ResponseDeleteFinger",
    "ResponseRenameFinger",
    "ResponseFingerprintSensorInfo",
    "ResponseDeleteAllFingers",
    "ResponseFingers",
    "ResponseCancelInstruction",
    nullptr
  };
  return names;
}

inline const char *EnumNameResponses(Responses e) {
  if (::flatbuffers::IsOutRange(e, Responses_NONE, Responses_ResponseCancelInstruction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesResponses()[index];
}

template<typename T> struct ResponsesTraits {
  static const Responses enum_value = Responses_NONE;
};

template<> struct ResponsesTraits<webmanager::NotifyCanMessage> {
  static const Responses enum_value = Responses_NotifyCanMessage;
};

template<> struct ResponsesTraits<webmanager::NotifyLiveLogItem> {
  static const Responses enum_value = Responses_NotifyLiveLogItem;
};

template<> struct ResponsesTraits<webmanager::ResponseNetworkInformation> {
  static const Responses enum_value = Responses_ResponseNetworkInformation;
};

template<> struct ResponsesTraits<webmanager::ResponseWifiConnectSuccessful> {
  static const Responses enum_value = Responses_ResponseWifiConnectSuccessful;
};

template<> struct ResponsesTraits<webmanager::ResponseWifiConnectFailed> {
  static const Responses enum_value = Responses_ResponseWifiConnectFailed;
};

template<> struct ResponsesTraits<webmanager::ResponseWifiDisconnect> {
  static const Responses enum_value = Responses_ResponseWifiDisconnect;
};

template<> struct ResponsesTraits<webmanager::ResponseSystemData> {
  static const Responses enum_value = Responses_ResponseSystemData;
};

template<> struct ResponsesTraits<webmanager::ResponseJournal> {
  static const Responses enum_value = Responses_ResponseJournal;
};

template<> struct ResponsesTraits<webmanager::ResponseGetUserSettings> {
  static const Responses enum_value = Responses_ResponseGetUserSettings;
};

template<> struct ResponsesTraits<webmanager::ResponseSetUserSettings> {
  static const Responses enum_value = Responses_ResponseSetUserSettings;
};

template<> struct ResponsesTraits<webmanager::ResponseTimeseriesDummy> {
  static const Responses enum_value = Responses_ResponseTimeseriesDummy;
};

template<> struct ResponsesTraits<webmanager::ResponseEnrollNewFinger> {
  static const Responses enum_value = Responses_ResponseEnrollNewFinger;
};

template<> struct ResponsesTraits<webmanager::NotifyEnrollNewFinger> {
  static const Responses enum_value = Responses_NotifyEnrollNewFinger;
};

template<> struct ResponsesTraits<webmanager::NotifyFingerDetected> {
  static const Responses enum_value = Responses_NotifyFingerDetected;
};

template<> struct ResponsesTraits<webmanager::ResponseDeleteFinger> {
  static const Responses enum_value = Responses_ResponseDeleteFinger;
};

template<> struct ResponsesTraits<webmanager::ResponseRenameFinger> {
  static const Responses enum_value = Responses_ResponseRenameFinger;
};

template<> struct ResponsesTraits<webmanager::ResponseFingerprintSensorInfo> {
  static const Responses enum_value = Responses_ResponseFingerprintSensorInfo;
};

template<> struct ResponsesTraits<webmanager::ResponseDeleteAllFingers> {
  static const Responses enum_value = Responses_ResponseDeleteAllFingers;
};

template<> struct ResponsesTraits<webmanager::ResponseFingers> {
  static const Responses enum_value = Responses_ResponseFingers;
};

template<> struct ResponsesTraits<webmanager::ResponseCancelInstruction> {
  static const Responses enum_value = Responses_ResponseCancelInstruction;
};

bool VerifyResponses(::flatbuffers::Verifier &verifier, const void *obj, Responses type);
bool VerifyResponsesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum Requests : uint8_t {
  Requests_NONE = 0,
  Requests_websensact_CommandMessage = 1,
  Requests_RequestNetworkInformation = 2,
  Requests_RequestWifiConnect = 3,
  Requests_RequestWifiDisconnect = 4,
  Requests_RequestSystemData = 5,
  Requests_RequestJournal = 6,
  Requests_RequestRestart = 7,
  Requests_RequestGetUserSettings = 8,
  Requests_RequestSetUserSettings = 9,
  Requests_RequestTimeseries = 10,
  Requests_RequestOpenDoor = 11,
  Requests_RequestEnrollNewFinger = 12,
  Requests_RequestDeleteFinger = 13,
  Requests_RequestDeleteAllFingers = 14,
  Requests_RequestRenameFinger = 15,
  Requests_RequestFingerprintSensorInfo = 16,
  Requests_RequestFingers = 17,
  Requests_RequestCancelInstruction = 18,
  Requests_MIN = Requests_NONE,
  Requests_MAX = Requests_RequestCancelInstruction
};

inline const Requests (&EnumValuesRequests())[19] {
  static const Requests values[] = {
    Requests_NONE,
    Requests_websensact_CommandMessage,
    Requests_RequestNetworkInformation,
    Requests_RequestWifiConnect,
    Requests_RequestWifiDisconnect,
    Requests_RequestSystemData,
    Requests_RequestJournal,
    Requests_RequestRestart,
    Requests_RequestGetUserSettings,
    Requests_RequestSetUserSettings,
    Requests_RequestTimeseries,
    Requests_RequestOpenDoor,
    Requests_RequestEnrollNewFinger,
    Requests_RequestDeleteFinger,
    Requests_RequestDeleteAllFingers,
    Requests_RequestRenameFinger,
    Requests_RequestFingerprintSensorInfo,
    Requests_RequestFingers,
    Requests_RequestCancelInstruction
  };
  return values;
}

inline const char * const *EnumNamesRequests() {
  static const char * const names[20] = {
    "NONE",
    "websensact_CommandMessage",
    "RequestNetworkInformation",
    "RequestWifiConnect",
    "RequestWifiDisconnect",
    "RequestSystemData",
    "RequestJournal",
    "RequestRestart",
    "RequestGetUserSettings",
    "RequestSetUserSettings",
    "RequestTimeseries",
    "RequestOpenDoor",
    "RequestEnrollNewFinger",
    "RequestDeleteFinger",
    "RequestDeleteAllFingers",
    "RequestRenameFinger",
    "RequestFingerprintSensorInfo",
    "RequestFingers",
    "RequestCancelInstruction",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequests(Requests e) {
  if (::flatbuffers::IsOutRange(e, Requests_NONE, Requests_RequestCancelInstruction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRequests()[index];
}

template<typename T> struct RequestsTraits {
  static const Requests enum_value = Requests_NONE;
};

template<> struct RequestsTraits<websensact::CommandMessage> {
  static const Requests enum_value = Requests_websensact_CommandMessage;
};

template<> struct RequestsTraits<webmanager::RequestNetworkInformation> {
  static const Requests enum_value = Requests_RequestNetworkInformation;
};

template<> struct RequestsTraits<webmanager::RequestWifiConnect> {
  static const Requests enum_value = Requests_RequestWifiConnect;
};

template<> struct RequestsTraits<webmanager::RequestWifiDisconnect> {
  static const Requests enum_value = Requests_RequestWifiDisconnect;
};

template<> struct RequestsTraits<webmanager::RequestSystemData> {
  static const Requests enum_value = Requests_RequestSystemData;
};

template<> struct RequestsTraits<webmanager::RequestJournal> {
  static const Requests enum_value = Requests_RequestJournal;
};

template<> struct RequestsTraits<webmanager::RequestRestart> {
  static const Requests enum_value = Requests_RequestRestart;
};

template<> struct RequestsTraits<webmanager::RequestGetUserSettings> {
  static const Requests enum_value = Requests_RequestGetUserSettings;
};

template<> struct RequestsTraits<webmanager::RequestSetUserSettings> {
  static const Requests enum_value = Requests_RequestSetUserSettings;
};

template<> struct RequestsTraits<webmanager::RequestTimeseries> {
  static const Requests enum_value = Requests_RequestTimeseries;
};

template<> struct RequestsTraits<webmanager::RequestOpenDoor> {
  static const Requests enum_value = Requests_RequestOpenDoor;
};

template<> struct RequestsTraits<webmanager::RequestEnrollNewFinger> {
  static const Requests enum_value = Requests_RequestEnrollNewFinger;
};

template<> struct RequestsTraits<webmanager::RequestDeleteFinger> {
  static const Requests enum_value = Requests_RequestDeleteFinger;
};

template<> struct RequestsTraits<webmanager::RequestDeleteAllFingers> {
  static const Requests enum_value = Requests_RequestDeleteAllFingers;
};

template<> struct RequestsTraits<webmanager::RequestRenameFinger> {
  static const Requests enum_value = Requests_RequestRenameFinger;
};

template<> struct RequestsTraits<webmanager::RequestFingerprintSensorInfo> {
  static const Requests enum_value = Requests_RequestFingerprintSensorInfo;
};

template<> struct RequestsTraits<webmanager::RequestFingers> {
  static const Requests enum_value = Requests_RequestFingers;
};

template<> struct RequestsTraits<webmanager::RequestCancelInstruction> {
  static const Requests enum_value = Requests_RequestCancelInstruction;
};

bool VerifyRequests(::flatbuffers::Verifier &verifier, const void *obj, Requests type);
bool VerifyRequestsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Mac6 FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t v_[6];

 public:
  Mac6()
      : v_() {
  }
  Mac6(::flatbuffers::span<const uint8_t, 6> _v) {
    ::flatbuffers::CastToArray(v_).CopyFromSpan(_v);
  }
  const ::flatbuffers::Array<uint8_t, 6> *v() const {
    return &::flatbuffers::CastToArray(v_);
  }
};
FLATBUFFERS_STRUCT_END(Mac6, 6);

}  // namespace webmanager

namespace websensact {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) MessagePayload FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t p_[8];

 public:
  MessagePayload()
      : p_() {
  }
  MessagePayload(::flatbuffers::span<const uint8_t, 8> _p) {
    ::flatbuffers::CastToArray(p_).CopyFromSpan(_p);
  }
  const ::flatbuffers::Array<uint8_t, 8> *p() const {
    return &::flatbuffers::CastToArray(p_);
  }
};
FLATBUFFERS_STRUCT_END(MessagePayload, 8);

}  // namespace websensact

namespace webmanager {

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) CanData FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t data_[8];

 public:
  CanData()
      : data_() {
  }
  CanData(::flatbuffers::span<const uint8_t, 8> _data) {
    ::flatbuffers::CastToArray(data_).CopyFromSpan(_data);
  }
  const ::flatbuffers::Array<uint8_t, 8> *data() const {
    return &::flatbuffers::CastToArray(data_);
  }
};
FLATBUFFERS_STRUCT_END(CanData, 8);

struct AccessPoint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccessPointBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_PRIMARY_CHANNEL = 6,
    VT_RSSI = 8,
    VT_AUTH_MODE = 10
  };
  const ::flatbuffers::String *ssid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SSID);
  }
  int32_t primary_channel() const {
    return GetField<int32_t>(VT_PRIMARY_CHANNEL, 0);
  }
  int32_t rssi() const {
    return GetField<int32_t>(VT_RSSI, 0);
  }
  int32_t auth_mode() const {
    return GetField<int32_t>(VT_AUTH_MODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyField<int32_t>(verifier, VT_PRIMARY_CHANNEL, 4) &&
           VerifyField<int32_t>(verifier, VT_RSSI, 4) &&
           VerifyField<int32_t>(verifier, VT_AUTH_MODE, 4) &&
           verifier.EndTable();
  }
};

struct AccessPointBuilder {
  typedef AccessPoint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ssid(::flatbuffers::Offset<::flatbuffers::String> ssid) {
    fbb_.AddOffset(AccessPoint::VT_SSID, ssid);
  }
  void add_primary_channel(int32_t primary_channel) {
    fbb_.AddElement<int32_t>(AccessPoint::VT_PRIMARY_CHANNEL, primary_channel, 0);
  }
  void add_rssi(int32_t rssi) {
    fbb_.AddElement<int32_t>(AccessPoint::VT_RSSI, rssi, 0);
  }
  void add_auth_mode(int32_t auth_mode) {
    fbb_.AddElement<int32_t>(AccessPoint::VT_AUTH_MODE, auth_mode, 0);
  }
  explicit AccessPointBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccessPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccessPoint>(end);
    fbb_.Required(o, AccessPoint::VT_SSID);
    return o;
  }
};

inline ::flatbuffers::Offset<AccessPoint> CreateAccessPoint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ssid = 0,
    int32_t primary_channel = 0,
    int32_t rssi = 0,
    int32_t auth_mode = 0) {
  AccessPointBuilder builder_(_fbb);
  builder_.add_auth_mode(auth_mode);
  builder_.add_rssi(rssi);
  builder_.add_primary_channel(primary_channel);
  builder_.add_ssid(ssid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AccessPoint> CreateAccessPointDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    int32_t primary_channel = 0,
    int32_t rssi = 0,
    int32_t auth_mode = 0) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  return webmanager::CreateAccessPoint(
      _fbb,
      ssid__,
      primary_channel,
      rssi,
      auth_mode);
}

struct RequestNetworkInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestNetworkInformationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORCENEWSEARCH = 4
  };
  bool forceNewSearch() const {
    return GetField<uint8_t>(VT_FORCENEWSEARCH, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FORCENEWSEARCH, 1) &&
           verifier.EndTable();
  }
};

struct RequestNetworkInformationBuilder {
  typedef RequestNetworkInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_forceNewSearch(bool forceNewSearch) {
    fbb_.AddElement<uint8_t>(RequestNetworkInformation::VT_FORCENEWSEARCH, static_cast<uint8_t>(forceNewSearch), 0);
  }
  explicit RequestNetworkInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestNetworkInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestNetworkInformation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestNetworkInformation> CreateRequestNetworkInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool forceNewSearch = false) {
  RequestNetworkInformationBuilder builder_(_fbb);
  builder_.add_forceNewSearch(forceNewSearch);
  return builder_.Finish();
}

struct ResponseNetworkInformation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseNetworkInformationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HOSTNAME = 4,
    VT_SSID_AP = 6,
    VT_PASSWORD_AP = 8,
    VT_IP_AP = 10,
    VT_IS_CONNECTED_STA = 12,
    VT_SSID_STA = 14,
    VT_IP_STA = 16,
    VT_NETMASK_STA = 18,
    VT_GATEWAY_STA = 20,
    VT_RSSI_STA = 22,
    VT_ACCESSPOINTS = 24
  };
  const ::flatbuffers::String *hostname() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HOSTNAME);
  }
  const ::flatbuffers::String *ssid_ap() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SSID_AP);
  }
  const ::flatbuffers::String *password_ap() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD_AP);
  }
  uint32_t ip_ap() const {
    return GetField<uint32_t>(VT_IP_AP, 0);
  }
  bool is_connected_sta() const {
    return GetField<uint8_t>(VT_IS_CONNECTED_STA, 0) != 0;
  }
  const ::flatbuffers::String *ssid_sta() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SSID_STA);
  }
  uint32_t ip_sta() const {
    return GetField<uint32_t>(VT_IP_STA, 0);
  }
  uint32_t netmask_sta() const {
    return GetField<uint32_t>(VT_NETMASK_STA, 0);
  }
  uint32_t gateway_sta() const {
    return GetField<uint32_t>(VT_GATEWAY_STA, 0);
  }
  int8_t rssi_sta() const {
    return GetField<int8_t>(VT_RSSI_STA, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::AccessPoint>> *accesspoints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::AccessPoint>> *>(VT_ACCESSPOINTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HOSTNAME) &&
           verifier.VerifyString(hostname()) &&
           VerifyOffset(verifier, VT_SSID_AP) &&
           verifier.VerifyString(ssid_ap()) &&
           VerifyOffset(verifier, VT_PASSWORD_AP) &&
           verifier.VerifyString(password_ap()) &&
           VerifyField<uint32_t>(verifier, VT_IP_AP, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_CONNECTED_STA, 1) &&
           VerifyOffset(verifier, VT_SSID_STA) &&
           verifier.VerifyString(ssid_sta()) &&
           VerifyField<uint32_t>(verifier, VT_IP_STA, 4) &&
           VerifyField<uint32_t>(verifier, VT_NETMASK_STA, 4) &&
           VerifyField<uint32_t>(verifier, VT_GATEWAY_STA, 4) &&
           VerifyField<int8_t>(verifier, VT_RSSI_STA, 1) &&
           VerifyOffsetRequired(verifier, VT_ACCESSPOINTS) &&
           verifier.VerifyVector(accesspoints()) &&
           verifier.VerifyVectorOfTables(accesspoints()) &&
           verifier.EndTable();
  }
};

struct ResponseNetworkInformationBuilder {
  typedef ResponseNetworkInformation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_hostname(::flatbuffers::Offset<::flatbuffers::String> hostname) {
    fbb_.AddOffset(ResponseNetworkInformation::VT_HOSTNAME, hostname);
  }
  void add_ssid_ap(::flatbuffers::Offset<::flatbuffers::String> ssid_ap) {
    fbb_.AddOffset(ResponseNetworkInformation::VT_SSID_AP, ssid_ap);
  }
  void add_password_ap(::flatbuffers::Offset<::flatbuffers::String> password_ap) {
    fbb_.AddOffset(ResponseNetworkInformation::VT_PASSWORD_AP, password_ap);
  }
  void add_ip_ap(uint32_t ip_ap) {
    fbb_.AddElement<uint32_t>(ResponseNetworkInformation::VT_IP_AP, ip_ap, 0);
  }
  void add_is_connected_sta(bool is_connected_sta) {
    fbb_.AddElement<uint8_t>(ResponseNetworkInformation::VT_IS_CONNECTED_STA, static_cast<uint8_t>(is_connected_sta), 0);
  }
  void add_ssid_sta(::flatbuffers::Offset<::flatbuffers::String> ssid_sta) {
    fbb_.AddOffset(ResponseNetworkInformation::VT_SSID_STA, ssid_sta);
  }
  void add_ip_sta(uint32_t ip_sta) {
    fbb_.AddElement<uint32_t>(ResponseNetworkInformation::VT_IP_STA, ip_sta, 0);
  }
  void add_netmask_sta(uint32_t netmask_sta) {
    fbb_.AddElement<uint32_t>(ResponseNetworkInformation::VT_NETMASK_STA, netmask_sta, 0);
  }
  void add_gateway_sta(uint32_t gateway_sta) {
    fbb_.AddElement<uint32_t>(ResponseNetworkInformation::VT_GATEWAY_STA, gateway_sta, 0);
  }
  void add_rssi_sta(int8_t rssi_sta) {
    fbb_.AddElement<int8_t>(ResponseNetworkInformation::VT_RSSI_STA, rssi_sta, 0);
  }
  void add_accesspoints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::AccessPoint>>> accesspoints) {
    fbb_.AddOffset(ResponseNetworkInformation::VT_ACCESSPOINTS, accesspoints);
  }
  explicit ResponseNetworkInformationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseNetworkInformation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseNetworkInformation>(end);
    fbb_.Required(o, ResponseNetworkInformation::VT_ACCESSPOINTS);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseNetworkInformation> CreateResponseNetworkInformation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> hostname = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ssid_ap = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password_ap = 0,
    uint32_t ip_ap = 0,
    bool is_connected_sta = false,
    ::flatbuffers::Offset<::flatbuffers::String> ssid_sta = 0,
    uint32_t ip_sta = 0,
    uint32_t netmask_sta = 0,
    uint32_t gateway_sta = 0,
    int8_t rssi_sta = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::AccessPoint>>> accesspoints = 0) {
  ResponseNetworkInformationBuilder builder_(_fbb);
  builder_.add_accesspoints(accesspoints);
  builder_.add_gateway_sta(gateway_sta);
  builder_.add_netmask_sta(netmask_sta);
  builder_.add_ip_sta(ip_sta);
  builder_.add_ssid_sta(ssid_sta);
  builder_.add_ip_ap(ip_ap);
  builder_.add_password_ap(password_ap);
  builder_.add_ssid_ap(ssid_ap);
  builder_.add_hostname(hostname);
  builder_.add_rssi_sta(rssi_sta);
  builder_.add_is_connected_sta(is_connected_sta);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseNetworkInformation> CreateResponseNetworkInformationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *hostname = nullptr,
    const char *ssid_ap = nullptr,
    const char *password_ap = nullptr,
    uint32_t ip_ap = 0,
    bool is_connected_sta = false,
    const char *ssid_sta = nullptr,
    uint32_t ip_sta = 0,
    uint32_t netmask_sta = 0,
    uint32_t gateway_sta = 0,
    int8_t rssi_sta = 0,
    const std::vector<::flatbuffers::Offset<webmanager::AccessPoint>> *accesspoints = nullptr) {
  auto hostname__ = hostname ? _fbb.CreateString(hostname) : 0;
  auto ssid_ap__ = ssid_ap ? _fbb.CreateString(ssid_ap) : 0;
  auto password_ap__ = password_ap ? _fbb.CreateString(password_ap) : 0;
  auto ssid_sta__ = ssid_sta ? _fbb.CreateString(ssid_sta) : 0;
  auto accesspoints__ = accesspoints ? _fbb.CreateVector<::flatbuffers::Offset<webmanager::AccessPoint>>(*accesspoints) : 0;
  return webmanager::CreateResponseNetworkInformation(
      _fbb,
      hostname__,
      ssid_ap__,
      password_ap__,
      ip_ap,
      is_connected_sta,
      ssid_sta__,
      ip_sta,
      netmask_sta,
      gateway_sta,
      rssi_sta,
      accesspoints__);
}

struct RequestWifiConnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestWifiConnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_PASSWORD = 6
  };
  const ::flatbuffers::String *ssid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SSID);
  }
  const ::flatbuffers::String *password() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
};

struct RequestWifiConnectBuilder {
  typedef RequestWifiConnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ssid(::flatbuffers::Offset<::flatbuffers::String> ssid) {
    fbb_.AddOffset(RequestWifiConnect::VT_SSID, ssid);
  }
  void add_password(::flatbuffers::Offset<::flatbuffers::String> password) {
    fbb_.AddOffset(RequestWifiConnect::VT_PASSWORD, password);
  }
  explicit RequestWifiConnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestWifiConnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestWifiConnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestWifiConnect> CreateRequestWifiConnect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ssid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> password = 0) {
  RequestWifiConnectBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_ssid(ssid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestWifiConnect> CreateRequestWifiConnectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    const char *password = nullptr) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return webmanager::CreateRequestWifiConnect(
      _fbb,
      ssid__,
      password__);
}

struct ResponseWifiConnectSuccessful FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseWifiConnectSuccessfulBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4,
    VT_IP = 6,
    VT_NETMASK = 8,
    VT_GATEWAY = 10,
    VT_RSSI = 12
  };
  const ::flatbuffers::String *ssid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SSID);
  }
  uint32_t ip() const {
    return GetField<uint32_t>(VT_IP, 0);
  }
  uint32_t netmask() const {
    return GetField<uint32_t>(VT_NETMASK, 0);
  }
  uint32_t gateway() const {
    return GetField<uint32_t>(VT_GATEWAY, 0);
  }
  int8_t rssi() const {
    return GetField<int8_t>(VT_RSSI, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           VerifyField<uint32_t>(verifier, VT_IP, 4) &&
           VerifyField<uint32_t>(verifier, VT_NETMASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_GATEWAY, 4) &&
           VerifyField<int8_t>(verifier, VT_RSSI, 1) &&
           verifier.EndTable();
  }
};

struct ResponseWifiConnectSuccessfulBuilder {
  typedef ResponseWifiConnectSuccessful Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ssid(::flatbuffers::Offset<::flatbuffers::String> ssid) {
    fbb_.AddOffset(ResponseWifiConnectSuccessful::VT_SSID, ssid);
  }
  void add_ip(uint32_t ip) {
    fbb_.AddElement<uint32_t>(ResponseWifiConnectSuccessful::VT_IP, ip, 0);
  }
  void add_netmask(uint32_t netmask) {
    fbb_.AddElement<uint32_t>(ResponseWifiConnectSuccessful::VT_NETMASK, netmask, 0);
  }
  void add_gateway(uint32_t gateway) {
    fbb_.AddElement<uint32_t>(ResponseWifiConnectSuccessful::VT_GATEWAY, gateway, 0);
  }
  void add_rssi(int8_t rssi) {
    fbb_.AddElement<int8_t>(ResponseWifiConnectSuccessful::VT_RSSI, rssi, 0);
  }
  explicit ResponseWifiConnectSuccessfulBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseWifiConnectSuccessful> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseWifiConnectSuccessful>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseWifiConnectSuccessful> CreateResponseWifiConnectSuccessful(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ssid = 0,
    uint32_t ip = 0,
    uint32_t netmask = 0,
    uint32_t gateway = 0,
    int8_t rssi = 0) {
  ResponseWifiConnectSuccessfulBuilder builder_(_fbb);
  builder_.add_gateway(gateway);
  builder_.add_netmask(netmask);
  builder_.add_ip(ip);
  builder_.add_ssid(ssid);
  builder_.add_rssi(rssi);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseWifiConnectSuccessful> CreateResponseWifiConnectSuccessfulDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr,
    uint32_t ip = 0,
    uint32_t netmask = 0,
    uint32_t gateway = 0,
    int8_t rssi = 0) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  return webmanager::CreateResponseWifiConnectSuccessful(
      _fbb,
      ssid__,
      ip,
      netmask,
      gateway,
      rssi);
}

struct ResponseWifiConnectFailed FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseWifiConnectFailedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SSID = 4
  };
  const ::flatbuffers::String *ssid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SSID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SSID) &&
           verifier.VerifyString(ssid()) &&
           verifier.EndTable();
  }
};

struct ResponseWifiConnectFailedBuilder {
  typedef ResponseWifiConnectFailed Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ssid(::flatbuffers::Offset<::flatbuffers::String> ssid) {
    fbb_.AddOffset(ResponseWifiConnectFailed::VT_SSID, ssid);
  }
  explicit ResponseWifiConnectFailedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseWifiConnectFailed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseWifiConnectFailed>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseWifiConnectFailed> CreateResponseWifiConnectFailed(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> ssid = 0) {
  ResponseWifiConnectFailedBuilder builder_(_fbb);
  builder_.add_ssid(ssid);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseWifiConnectFailed> CreateResponseWifiConnectFailedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *ssid = nullptr) {
  auto ssid__ = ssid ? _fbb.CreateString(ssid) : 0;
  return webmanager::CreateResponseWifiConnectFailed(
      _fbb,
      ssid__);
}

struct RequestWifiDisconnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestWifiDisconnectBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestWifiDisconnectBuilder {
  typedef RequestWifiDisconnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestWifiDisconnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestWifiDisconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestWifiDisconnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestWifiDisconnect> CreateRequestWifiDisconnect(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestWifiDisconnectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ResponseWifiDisconnect FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseWifiDisconnectBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResponseWifiDisconnectBuilder {
  typedef ResponseWifiDisconnect Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ResponseWifiDisconnectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseWifiDisconnect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseWifiDisconnect>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseWifiDisconnect> CreateResponseWifiDisconnect(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ResponseWifiDisconnectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RequestRestart FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestRestartBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestRestartBuilder {
  typedef RequestRestart Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestRestartBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestRestart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestRestart>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestRestart> CreateRequestRestart(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestRestartBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RequestSystemData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestSystemDataBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestSystemDataBuilder {
  typedef RequestSystemData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestSystemDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestSystemData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestSystemData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestSystemData> CreateRequestSystemData(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestSystemDataBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PartitionInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PartitionInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_TYPE = 6,
    VT_SUBTYPE = 8,
    VT_SIZE = 10,
    VT_OTA_STATE = 12,
    VT_RUNNING = 14,
    VT_APP_NAME = 16,
    VT_APP_VERSION = 18,
    VT_APP_DATE = 20,
    VT_APP_TIME = 22
  };
  const ::flatbuffers::String *label() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LABEL);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint8_t subtype() const {
    return GetField<uint8_t>(VT_SUBTYPE, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  int8_t ota_state() const {
    return GetField<int8_t>(VT_OTA_STATE, 0);
  }
  bool running() const {
    return GetField<uint8_t>(VT_RUNNING, 0) != 0;
  }
  const ::flatbuffers::String *app_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APP_NAME);
  }
  const ::flatbuffers::String *app_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APP_VERSION);
  }
  const ::flatbuffers::String *app_date() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APP_DATE);
  }
  const ::flatbuffers::String *app_time() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APP_TIME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_SUBTYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<int8_t>(verifier, VT_OTA_STATE, 1) &&
           VerifyField<uint8_t>(verifier, VT_RUNNING, 1) &&
           VerifyOffset(verifier, VT_APP_NAME) &&
           verifier.VerifyString(app_name()) &&
           VerifyOffset(verifier, VT_APP_VERSION) &&
           verifier.VerifyString(app_version()) &&
           VerifyOffset(verifier, VT_APP_DATE) &&
           verifier.VerifyString(app_date()) &&
           VerifyOffset(verifier, VT_APP_TIME) &&
           verifier.VerifyString(app_time()) &&
           verifier.EndTable();
  }
};

struct PartitionInfoBuilder {
  typedef PartitionInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_label(::flatbuffers::Offset<::flatbuffers::String> label) {
    fbb_.AddOffset(PartitionInfo::VT_LABEL, label);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(PartitionInfo::VT_TYPE, type, 0);
  }
  void add_subtype(uint8_t subtype) {
    fbb_.AddElement<uint8_t>(PartitionInfo::VT_SUBTYPE, subtype, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(PartitionInfo::VT_SIZE, size, 0);
  }
  void add_ota_state(int8_t ota_state) {
    fbb_.AddElement<int8_t>(PartitionInfo::VT_OTA_STATE, ota_state, 0);
  }
  void add_running(bool running) {
    fbb_.AddElement<uint8_t>(PartitionInfo::VT_RUNNING, static_cast<uint8_t>(running), 0);
  }
  void add_app_name(::flatbuffers::Offset<::flatbuffers::String> app_name) {
    fbb_.AddOffset(PartitionInfo::VT_APP_NAME, app_name);
  }
  void add_app_version(::flatbuffers::Offset<::flatbuffers::String> app_version) {
    fbb_.AddOffset(PartitionInfo::VT_APP_VERSION, app_version);
  }
  void add_app_date(::flatbuffers::Offset<::flatbuffers::String> app_date) {
    fbb_.AddOffset(PartitionInfo::VT_APP_DATE, app_date);
  }
  void add_app_time(::flatbuffers::Offset<::flatbuffers::String> app_time) {
    fbb_.AddOffset(PartitionInfo::VT_APP_TIME, app_time);
  }
  explicit PartitionInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PartitionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PartitionInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PartitionInfo> CreatePartitionInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> label = 0,
    uint8_t type = 0,
    uint8_t subtype = 0,
    uint32_t size = 0,
    int8_t ota_state = 0,
    bool running = false,
    ::flatbuffers::Offset<::flatbuffers::String> app_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> app_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> app_date = 0,
    ::flatbuffers::Offset<::flatbuffers::String> app_time = 0) {
  PartitionInfoBuilder builder_(_fbb);
  builder_.add_app_time(app_time);
  builder_.add_app_date(app_date);
  builder_.add_app_version(app_version);
  builder_.add_app_name(app_name);
  builder_.add_size(size);
  builder_.add_label(label);
  builder_.add_running(running);
  builder_.add_ota_state(ota_state);
  builder_.add_subtype(subtype);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PartitionInfo> CreatePartitionInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    uint8_t type = 0,
    uint8_t subtype = 0,
    uint32_t size = 0,
    int8_t ota_state = 0,
    bool running = false,
    const char *app_name = nullptr,
    const char *app_version = nullptr,
    const char *app_date = nullptr,
    const char *app_time = nullptr) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  auto app_name__ = app_name ? _fbb.CreateString(app_name) : 0;
  auto app_version__ = app_version ? _fbb.CreateString(app_version) : 0;
  auto app_date__ = app_date ? _fbb.CreateString(app_date) : 0;
  auto app_time__ = app_time ? _fbb.CreateString(app_time) : 0;
  return webmanager::CreatePartitionInfo(
      _fbb,
      label__,
      type,
      subtype,
      size,
      ota_state,
      running,
      app_name__,
      app_version__,
      app_date__,
      app_time__);
}

struct ResponseSystemData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseSystemDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SECONDS_EPOCH = 4,
    VT_SECONDS_UPTIME = 6,
    VT_FREE_HEAP = 8,
    VT_MAC_ADDRESS_WIFI_STA = 10,
    VT_MAC_ADDRESS_WIFI_SOFTAP = 12,
    VT_MAC_ADDRESS_BT = 14,
    VT_MAC_ADDRESS_ETH = 16,
    VT_MAC_ADDRESS_IEEE802154 = 18,
    VT_CHIP_MODEL = 20,
    VT_CHIP_FEATURES = 22,
    VT_CHIP_REVISION = 24,
    VT_CHIP_CORES = 26,
    VT_CHIP_TEMPERATURE = 28,
    VT_PARTITIONS = 30
  };
  int64_t seconds_epoch() const {
    return GetField<int64_t>(VT_SECONDS_EPOCH, 0);
  }
  int64_t seconds_uptime() const {
    return GetField<int64_t>(VT_SECONDS_UPTIME, 0);
  }
  uint32_t free_heap() const {
    return GetField<uint32_t>(VT_FREE_HEAP, 0);
  }
  const webmanager::Mac6 *mac_address_wifi_sta() const {
    return GetStruct<const webmanager::Mac6 *>(VT_MAC_ADDRESS_WIFI_STA);
  }
  const webmanager::Mac6 *mac_address_wifi_softap() const {
    return GetStruct<const webmanager::Mac6 *>(VT_MAC_ADDRESS_WIFI_SOFTAP);
  }
  const webmanager::Mac6 *mac_address_bt() const {
    return GetStruct<const webmanager::Mac6 *>(VT_MAC_ADDRESS_BT);
  }
  const webmanager::Mac6 *mac_address_eth() const {
    return GetStruct<const webmanager::Mac6 *>(VT_MAC_ADDRESS_ETH);
  }
  const webmanager::Mac6 *mac_address_ieee802154() const {
    return GetStruct<const webmanager::Mac6 *>(VT_MAC_ADDRESS_IEEE802154);
  }
  uint32_t chip_model() const {
    return GetField<uint32_t>(VT_CHIP_MODEL, 0);
  }
  uint8_t chip_features() const {
    return GetField<uint8_t>(VT_CHIP_FEATURES, 0);
  }
  uint16_t chip_revision() const {
    return GetField<uint16_t>(VT_CHIP_REVISION, 0);
  }
  uint8_t chip_cores() const {
    return GetField<uint8_t>(VT_CHIP_CORES, 0);
  }
  float chip_temperature() const {
    return GetField<float>(VT_CHIP_TEMPERATURE, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::PartitionInfo>> *partitions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::PartitionInfo>> *>(VT_PARTITIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SECONDS_EPOCH, 8) &&
           VerifyField<int64_t>(verifier, VT_SECONDS_UPTIME, 8) &&
           VerifyField<uint32_t>(verifier, VT_FREE_HEAP, 4) &&
           VerifyField<webmanager::Mac6>(verifier, VT_MAC_ADDRESS_WIFI_STA, 1) &&
           VerifyField<webmanager::Mac6>(verifier, VT_MAC_ADDRESS_WIFI_SOFTAP, 1) &&
           VerifyField<webmanager::Mac6>(verifier, VT_MAC_ADDRESS_BT, 1) &&
           VerifyField<webmanager::Mac6>(verifier, VT_MAC_ADDRESS_ETH, 1) &&
           VerifyField<webmanager::Mac6>(verifier, VT_MAC_ADDRESS_IEEE802154, 1) &&
           VerifyField<uint32_t>(verifier, VT_CHIP_MODEL, 4) &&
           VerifyField<uint8_t>(verifier, VT_CHIP_FEATURES, 1) &&
           VerifyField<uint16_t>(verifier, VT_CHIP_REVISION, 2) &&
           VerifyField<uint8_t>(verifier, VT_CHIP_CORES, 1) &&
           VerifyField<float>(verifier, VT_CHIP_TEMPERATURE, 4) &&
           VerifyOffset(verifier, VT_PARTITIONS) &&
           verifier.VerifyVector(partitions()) &&
           verifier.VerifyVectorOfTables(partitions()) &&
           verifier.EndTable();
  }
};

struct ResponseSystemDataBuilder {
  typedef ResponseSystemData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seconds_epoch(int64_t seconds_epoch) {
    fbb_.AddElement<int64_t>(ResponseSystemData::VT_SECONDS_EPOCH, seconds_epoch, 0);
  }
  void add_seconds_uptime(int64_t seconds_uptime) {
    fbb_.AddElement<int64_t>(ResponseSystemData::VT_SECONDS_UPTIME, seconds_uptime, 0);
  }
  void add_free_heap(uint32_t free_heap) {
    fbb_.AddElement<uint32_t>(ResponseSystemData::VT_FREE_HEAP, free_heap, 0);
  }
  void add_mac_address_wifi_sta(const webmanager::Mac6 *mac_address_wifi_sta) {
    fbb_.AddStruct(ResponseSystemData::VT_MAC_ADDRESS_WIFI_STA, mac_address_wifi_sta);
  }
  void add_mac_address_wifi_softap(const webmanager::Mac6 *mac_address_wifi_softap) {
    fbb_.AddStruct(ResponseSystemData::VT_MAC_ADDRESS_WIFI_SOFTAP, mac_address_wifi_softap);
  }
  void add_mac_address_bt(const webmanager::Mac6 *mac_address_bt) {
    fbb_.AddStruct(ResponseSystemData::VT_MAC_ADDRESS_BT, mac_address_bt);
  }
  void add_mac_address_eth(const webmanager::Mac6 *mac_address_eth) {
    fbb_.AddStruct(ResponseSystemData::VT_MAC_ADDRESS_ETH, mac_address_eth);
  }
  void add_mac_address_ieee802154(const webmanager::Mac6 *mac_address_ieee802154) {
    fbb_.AddStruct(ResponseSystemData::VT_MAC_ADDRESS_IEEE802154, mac_address_ieee802154);
  }
  void add_chip_model(uint32_t chip_model) {
    fbb_.AddElement<uint32_t>(ResponseSystemData::VT_CHIP_MODEL, chip_model, 0);
  }
  void add_chip_features(uint8_t chip_features) {
    fbb_.AddElement<uint8_t>(ResponseSystemData::VT_CHIP_FEATURES, chip_features, 0);
  }
  void add_chip_revision(uint16_t chip_revision) {
    fbb_.AddElement<uint16_t>(ResponseSystemData::VT_CHIP_REVISION, chip_revision, 0);
  }
  void add_chip_cores(uint8_t chip_cores) {
    fbb_.AddElement<uint8_t>(ResponseSystemData::VT_CHIP_CORES, chip_cores, 0);
  }
  void add_chip_temperature(float chip_temperature) {
    fbb_.AddElement<float>(ResponseSystemData::VT_CHIP_TEMPERATURE, chip_temperature, 0.0f);
  }
  void add_partitions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::PartitionInfo>>> partitions) {
    fbb_.AddOffset(ResponseSystemData::VT_PARTITIONS, partitions);
  }
  explicit ResponseSystemDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseSystemData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseSystemData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseSystemData> CreateResponseSystemData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seconds_epoch = 0,
    int64_t seconds_uptime = 0,
    uint32_t free_heap = 0,
    const webmanager::Mac6 *mac_address_wifi_sta = nullptr,
    const webmanager::Mac6 *mac_address_wifi_softap = nullptr,
    const webmanager::Mac6 *mac_address_bt = nullptr,
    const webmanager::Mac6 *mac_address_eth = nullptr,
    const webmanager::Mac6 *mac_address_ieee802154 = nullptr,
    uint32_t chip_model = 0,
    uint8_t chip_features = 0,
    uint16_t chip_revision = 0,
    uint8_t chip_cores = 0,
    float chip_temperature = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::PartitionInfo>>> partitions = 0) {
  ResponseSystemDataBuilder builder_(_fbb);
  builder_.add_seconds_uptime(seconds_uptime);
  builder_.add_seconds_epoch(seconds_epoch);
  builder_.add_partitions(partitions);
  builder_.add_chip_temperature(chip_temperature);
  builder_.add_chip_model(chip_model);
  builder_.add_mac_address_ieee802154(mac_address_ieee802154);
  builder_.add_mac_address_eth(mac_address_eth);
  builder_.add_mac_address_bt(mac_address_bt);
  builder_.add_mac_address_wifi_softap(mac_address_wifi_softap);
  builder_.add_mac_address_wifi_sta(mac_address_wifi_sta);
  builder_.add_free_heap(free_heap);
  builder_.add_chip_revision(chip_revision);
  builder_.add_chip_cores(chip_cores);
  builder_.add_chip_features(chip_features);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseSystemData> CreateResponseSystemDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seconds_epoch = 0,
    int64_t seconds_uptime = 0,
    uint32_t free_heap = 0,
    const webmanager::Mac6 *mac_address_wifi_sta = nullptr,
    const webmanager::Mac6 *mac_address_wifi_softap = nullptr,
    const webmanager::Mac6 *mac_address_bt = nullptr,
    const webmanager::Mac6 *mac_address_eth = nullptr,
    const webmanager::Mac6 *mac_address_ieee802154 = nullptr,
    uint32_t chip_model = 0,
    uint8_t chip_features = 0,
    uint16_t chip_revision = 0,
    uint8_t chip_cores = 0,
    float chip_temperature = 0.0f,
    const std::vector<::flatbuffers::Offset<webmanager::PartitionInfo>> *partitions = nullptr) {
  auto partitions__ = partitions ? _fbb.CreateVector<::flatbuffers::Offset<webmanager::PartitionInfo>>(*partitions) : 0;
  return webmanager::CreateResponseSystemData(
      _fbb,
      seconds_epoch,
      seconds_uptime,
      free_heap,
      mac_address_wifi_sta,
      mac_address_wifi_softap,
      mac_address_bt,
      mac_address_eth,
      mac_address_ieee802154,
      chip_model,
      chip_features,
      chip_revision,
      chip_cores,
      chip_temperature,
      partitions__);
}

struct StringSetting FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringSettingBuilder {
  typedef StringSetting Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StringSetting::VT_VALUE, value);
  }
  explicit StringSettingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringSetting>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringSetting> CreateStringSetting(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringSettingBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringSetting> CreateStringSettingDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return webmanager::CreateStringSetting(
      _fbb,
      value__);
}

struct IntegerSetting FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntegerSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct IntegerSettingBuilder {
  typedef IntegerSetting Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(IntegerSetting::VT_VALUE, value, 0);
  }
  explicit IntegerSettingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntegerSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntegerSetting>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntegerSetting> CreateIntegerSetting(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntegerSettingBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct BooleanSetting FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BooleanSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BooleanSettingBuilder {
  typedef BooleanSetting Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BooleanSetting::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BooleanSettingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BooleanSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BooleanSetting>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BooleanSetting> CreateBooleanSetting(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BooleanSettingBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct EnumSetting FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumSettingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct EnumSettingBuilder {
  typedef EnumSetting Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(EnumSetting::VT_VALUE, value, 0);
  }
  explicit EnumSettingBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumSetting>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumSetting> CreateEnumSetting(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  EnumSettingBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct SettingWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SettingWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SETTINGKEY = 4,
    VT_SETTING_TYPE = 6,
    VT_SETTING = 8
  };
  const ::flatbuffers::String *settingKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SETTINGKEY);
  }
  webmanager::Setting setting_type() const {
    return static_cast<webmanager::Setting>(GetField<uint8_t>(VT_SETTING_TYPE, 0));
  }
  const void *setting() const {
    return GetPointer<const void *>(VT_SETTING);
  }
  template<typename T> const T *setting_as() const;
  const webmanager::StringSetting *setting_as_StringSetting() const {
    return setting_type() == webmanager::Setting_StringSetting ? static_cast<const webmanager::StringSetting *>(setting()) : nullptr;
  }
  const webmanager::IntegerSetting *setting_as_IntegerSetting() const {
    return setting_type() == webmanager::Setting_IntegerSetting ? static_cast<const webmanager::IntegerSetting *>(setting()) : nullptr;
  }
  const webmanager::BooleanSetting *setting_as_BooleanSetting() const {
    return setting_type() == webmanager::Setting_BooleanSetting ? static_cast<const webmanager::BooleanSetting *>(setting()) : nullptr;
  }
  const webmanager::EnumSetting *setting_as_EnumSetting() const {
    return setting_type() == webmanager::Setting_EnumSetting ? static_cast<const webmanager::EnumSetting *>(setting()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SETTINGKEY) &&
           verifier.VerifyString(settingKey()) &&
           VerifyField<uint8_t>(verifier, VT_SETTING_TYPE, 1) &&
           VerifyOffset(verifier, VT_SETTING) &&
           VerifySetting(verifier, setting(), setting_type()) &&
           verifier.EndTable();
  }
};

template<> inline const webmanager::StringSetting *SettingWrapper::setting_as<webmanager::StringSetting>() const {
  return setting_as_StringSetting();
}

template<> inline const webmanager::IntegerSetting *SettingWrapper::setting_as<webmanager::IntegerSetting>() const {
  return setting_as_IntegerSetting();
}

template<> inline const webmanager::BooleanSetting *SettingWrapper::setting_as<webmanager::BooleanSetting>() const {
  return setting_as_BooleanSetting();
}

template<> inline const webmanager::EnumSetting *SettingWrapper::setting_as<webmanager::EnumSetting>() const {
  return setting_as_EnumSetting();
}

struct SettingWrapperBuilder {
  typedef SettingWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_settingKey(::flatbuffers::Offset<::flatbuffers::String> settingKey) {
    fbb_.AddOffset(SettingWrapper::VT_SETTINGKEY, settingKey);
  }
  void add_setting_type(webmanager::Setting setting_type) {
    fbb_.AddElement<uint8_t>(SettingWrapper::VT_SETTING_TYPE, static_cast<uint8_t>(setting_type), 0);
  }
  void add_setting(::flatbuffers::Offset<void> setting) {
    fbb_.AddOffset(SettingWrapper::VT_SETTING, setting);
  }
  explicit SettingWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SettingWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SettingWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SettingWrapper> CreateSettingWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> settingKey = 0,
    webmanager::Setting setting_type = webmanager::Setting_NONE,
    ::flatbuffers::Offset<void> setting = 0) {
  SettingWrapperBuilder builder_(_fbb);
  builder_.add_setting(setting);
  builder_.add_settingKey(settingKey);
  builder_.add_setting_type(setting_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SettingWrapper> CreateSettingWrapperDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *settingKey = nullptr,
    webmanager::Setting setting_type = webmanager::Setting_NONE,
    ::flatbuffers::Offset<void> setting = 0) {
  auto settingKey__ = settingKey ? _fbb.CreateString(settingKey) : 0;
  return webmanager::CreateSettingWrapper(
      _fbb,
      settingKey__,
      setting_type,
      setting);
}

struct RequestGetUserSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestGetUserSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUPKEY = 4
  };
  const ::flatbuffers::String *groupKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUPKEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUPKEY) &&
           verifier.VerifyString(groupKey()) &&
           verifier.EndTable();
  }
};

struct RequestGetUserSettingsBuilder {
  typedef RequestGetUserSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_groupKey(::flatbuffers::Offset<::flatbuffers::String> groupKey) {
    fbb_.AddOffset(RequestGetUserSettings::VT_GROUPKEY, groupKey);
  }
  explicit RequestGetUserSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestGetUserSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestGetUserSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestGetUserSettings> CreateRequestGetUserSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> groupKey = 0) {
  RequestGetUserSettingsBuilder builder_(_fbb);
  builder_.add_groupKey(groupKey);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestGetUserSettings> CreateRequestGetUserSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *groupKey = nullptr) {
  auto groupKey__ = groupKey ? _fbb.CreateString(groupKey) : 0;
  return webmanager::CreateRequestGetUserSettings(
      _fbb,
      groupKey__);
}

struct ResponseGetUserSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseGetUserSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUPKEY = 4,
    VT_SETTINGS = 6
  };
  const ::flatbuffers::String *groupKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUPKEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::SettingWrapper>> *settings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::SettingWrapper>> *>(VT_SETTINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUPKEY) &&
           verifier.VerifyString(groupKey()) &&
           VerifyOffset(verifier, VT_SETTINGS) &&
           verifier.VerifyVector(settings()) &&
           verifier.VerifyVectorOfTables(settings()) &&
           verifier.EndTable();
  }
};

struct ResponseGetUserSettingsBuilder {
  typedef ResponseGetUserSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_groupKey(::flatbuffers::Offset<::flatbuffers::String> groupKey) {
    fbb_.AddOffset(ResponseGetUserSettings::VT_GROUPKEY, groupKey);
  }
  void add_settings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::SettingWrapper>>> settings) {
    fbb_.AddOffset(ResponseGetUserSettings::VT_SETTINGS, settings);
  }
  explicit ResponseGetUserSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseGetUserSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseGetUserSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseGetUserSettings> CreateResponseGetUserSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> groupKey = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::SettingWrapper>>> settings = 0) {
  ResponseGetUserSettingsBuilder builder_(_fbb);
  builder_.add_settings(settings);
  builder_.add_groupKey(groupKey);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseGetUserSettings> CreateResponseGetUserSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *groupKey = nullptr,
    const std::vector<::flatbuffers::Offset<webmanager::SettingWrapper>> *settings = nullptr) {
  auto groupKey__ = groupKey ? _fbb.CreateString(groupKey) : 0;
  auto settings__ = settings ? _fbb.CreateVector<::flatbuffers::Offset<webmanager::SettingWrapper>>(*settings) : 0;
  return webmanager::CreateResponseGetUserSettings(
      _fbb,
      groupKey__,
      settings__);
}

struct RequestSetUserSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestSetUserSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUPKEY = 4,
    VT_SETTINGS = 6
  };
  const ::flatbuffers::String *groupKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUPKEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::SettingWrapper>> *settings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::SettingWrapper>> *>(VT_SETTINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUPKEY) &&
           verifier.VerifyString(groupKey()) &&
           VerifyOffset(verifier, VT_SETTINGS) &&
           verifier.VerifyVector(settings()) &&
           verifier.VerifyVectorOfTables(settings()) &&
           verifier.EndTable();
  }
};

struct RequestSetUserSettingsBuilder {
  typedef RequestSetUserSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_groupKey(::flatbuffers::Offset<::flatbuffers::String> groupKey) {
    fbb_.AddOffset(RequestSetUserSettings::VT_GROUPKEY, groupKey);
  }
  void add_settings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::SettingWrapper>>> settings) {
    fbb_.AddOffset(RequestSetUserSettings::VT_SETTINGS, settings);
  }
  explicit RequestSetUserSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestSetUserSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestSetUserSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestSetUserSettings> CreateRequestSetUserSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> groupKey = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::SettingWrapper>>> settings = 0) {
  RequestSetUserSettingsBuilder builder_(_fbb);
  builder_.add_settings(settings);
  builder_.add_groupKey(groupKey);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestSetUserSettings> CreateRequestSetUserSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *groupKey = nullptr,
    const std::vector<::flatbuffers::Offset<webmanager::SettingWrapper>> *settings = nullptr) {
  auto groupKey__ = groupKey ? _fbb.CreateString(groupKey) : 0;
  auto settings__ = settings ? _fbb.CreateVector<::flatbuffers::Offset<webmanager::SettingWrapper>>(*settings) : 0;
  return webmanager::CreateRequestSetUserSettings(
      _fbb,
      groupKey__,
      settings__);
}

struct ResponseSetUserSettings FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseSetUserSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUPKEY = 4,
    VT_SETTINGKEYS = 6
  };
  const ::flatbuffers::String *groupKey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUPKEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *settingKeys() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SETTINGKEYS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUPKEY) &&
           verifier.VerifyString(groupKey()) &&
           VerifyOffset(verifier, VT_SETTINGKEYS) &&
           verifier.VerifyVector(settingKeys()) &&
           verifier.VerifyVectorOfStrings(settingKeys()) &&
           verifier.EndTable();
  }
};

struct ResponseSetUserSettingsBuilder {
  typedef ResponseSetUserSettings Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_groupKey(::flatbuffers::Offset<::flatbuffers::String> groupKey) {
    fbb_.AddOffset(ResponseSetUserSettings::VT_GROUPKEY, groupKey);
  }
  void add_settingKeys(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> settingKeys) {
    fbb_.AddOffset(ResponseSetUserSettings::VT_SETTINGKEYS, settingKeys);
  }
  explicit ResponseSetUserSettingsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseSetUserSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseSetUserSettings>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseSetUserSettings> CreateResponseSetUserSettings(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> groupKey = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> settingKeys = 0) {
  ResponseSetUserSettingsBuilder builder_(_fbb);
  builder_.add_settingKeys(settingKeys);
  builder_.add_groupKey(groupKey);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseSetUserSettings> CreateResponseSetUserSettingsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *groupKey = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *settingKeys = nullptr) {
  auto groupKey__ = groupKey ? _fbb.CreateString(groupKey) : 0;
  auto settingKeys__ = settingKeys ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*settingKeys) : 0;
  return webmanager::CreateResponseSetUserSettings(
      _fbb,
      groupKey__,
      settingKeys__);
}

struct RequestTimeseries FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestTimeseriesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRANULARITY = 4,
    VT_OFFSET = 6
  };
  webmanager::TimeGranularity granularity() const {
    return static_cast<webmanager::TimeGranularity>(GetField<int8_t>(VT_GRANULARITY, 0));
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_GRANULARITY, 1) &&
           VerifyField<int32_t>(verifier, VT_OFFSET, 4) &&
           verifier.EndTable();
  }
};

struct RequestTimeseriesBuilder {
  typedef RequestTimeseries Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_granularity(webmanager::TimeGranularity granularity) {
    fbb_.AddElement<int8_t>(RequestTimeseries::VT_GRANULARITY, static_cast<int8_t>(granularity), 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(RequestTimeseries::VT_OFFSET, offset, 0);
  }
  explicit RequestTimeseriesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestTimeseries> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestTimeseries>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestTimeseries> CreateRequestTimeseries(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    webmanager::TimeGranularity granularity = webmanager::TimeGranularity_TEN_SECONDS,
    int32_t offset = 0) {
  RequestTimeseriesBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_granularity(granularity);
  return builder_.Finish();
}

struct ResponseTimeseriesDummy FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseTimeseriesDummyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRANULARITY = 4
  };
  webmanager::TimeGranularity granularity() const {
    return static_cast<webmanager::TimeGranularity>(GetField<int8_t>(VT_GRANULARITY, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_GRANULARITY, 1) &&
           verifier.EndTable();
  }
};

struct ResponseTimeseriesDummyBuilder {
  typedef ResponseTimeseriesDummy Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_granularity(webmanager::TimeGranularity granularity) {
    fbb_.AddElement<int8_t>(ResponseTimeseriesDummy::VT_GRANULARITY, static_cast<int8_t>(granularity), 0);
  }
  explicit ResponseTimeseriesDummyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseTimeseriesDummy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseTimeseriesDummy>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseTimeseriesDummy> CreateResponseTimeseriesDummy(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    webmanager::TimeGranularity granularity = webmanager::TimeGranularity_TEN_SECONDS) {
  ResponseTimeseriesDummyBuilder builder_(_fbb);
  builder_.add_granularity(granularity);
  return builder_.Finish();
}

}  // namespace webmanager

namespace websensact {

struct CommandMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CMD = 6,
    VT_PAYLOAD = 8
  };
  ApplicationId id() const {
    return static_cast<ApplicationId>(GetField<uint16_t>(VT_ID, 0));
  }
  Command cmd() const {
    return static_cast<Command>(GetField<int8_t>(VT_CMD, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *payload() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ID, 2) &&
           VerifyField<int8_t>(verifier, VT_CMD, 1) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct CommandMessageBuilder {
  typedef CommandMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(ApplicationId id) {
    fbb_.AddElement<uint16_t>(CommandMessage::VT_ID, static_cast<uint16_t>(id), 0);
  }
  void add_cmd(Command cmd) {
    fbb_.AddElement<int8_t>(CommandMessage::VT_CMD, static_cast<int8_t>(cmd), 0);
  }
  void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
    fbb_.AddOffset(CommandMessage::VT_PAYLOAD, payload);
  }
  explicit CommandMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CommandMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CommandMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CommandMessage> CreateCommandMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ApplicationId id = ApplicationId_ApplicationId_MASTER,
    Command cmd = Command_NOP,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
  CommandMessageBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_id(id);
  builder_.add_cmd(cmd);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CommandMessage> CreateCommandMessageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ApplicationId id = ApplicationId_ApplicationId_MASTER,
    Command cmd = Command_NOP,
    const std::vector<uint8_t> *payload = nullptr) {
  auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
  return websensact::CreateCommandMessage(
      _fbb,
      id,
      cmd,
      payload__);
}

}  // namespace websensact

namespace webmanager {

struct RequestOpenDoor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestOpenDoorBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestOpenDoorBuilder {
  typedef RequestOpenDoor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestOpenDoorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestOpenDoor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestOpenDoor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestOpenDoor> CreateRequestOpenDoor(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestOpenDoorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RequestEnrollNewFinger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestEnrollNewFingerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RequestEnrollNewFingerBuilder {
  typedef RequestEnrollNewFinger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(RequestEnrollNewFinger::VT_NAME, name);
  }
  explicit RequestEnrollNewFingerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestEnrollNewFinger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestEnrollNewFinger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestEnrollNewFinger> CreateRequestEnrollNewFinger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  RequestEnrollNewFingerBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestEnrollNewFinger> CreateRequestEnrollNewFingerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return webmanager::CreateRequestEnrollNewFinger(
      _fbb,
      name__);
}

struct ResponseEnrollNewFinger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseEnrollNewFingerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4
  };
  uint16_t errorcode() const {
    return GetField<uint16_t>(VT_ERRORCODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERRORCODE, 2) &&
           verifier.EndTable();
  }
};

struct ResponseEnrollNewFingerBuilder {
  typedef ResponseEnrollNewFinger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(uint16_t errorcode) {
    fbb_.AddElement<uint16_t>(ResponseEnrollNewFinger::VT_ERRORCODE, errorcode, 0);
  }
  explicit ResponseEnrollNewFingerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseEnrollNewFinger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseEnrollNewFinger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseEnrollNewFinger> CreateResponseEnrollNewFinger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t errorcode = 0) {
  ResponseEnrollNewFingerBuilder builder_(_fbb);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

struct NotifyEnrollNewFinger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotifyEnrollNewFingerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INDEX = 6,
    VT_STEP = 8,
    VT_ERRORCODE = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint16_t index() const {
    return GetField<uint16_t>(VT_INDEX, 0);
  }
  uint8_t step() const {
    return GetField<uint8_t>(VT_STEP, 0);
  }
  uint16_t errorcode() const {
    return GetField<uint16_t>(VT_ERRORCODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_INDEX, 2) &&
           VerifyField<uint8_t>(verifier, VT_STEP, 1) &&
           VerifyField<uint16_t>(verifier, VT_ERRORCODE, 2) &&
           verifier.EndTable();
  }
};

struct NotifyEnrollNewFingerBuilder {
  typedef NotifyEnrollNewFinger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NotifyEnrollNewFinger::VT_NAME, name);
  }
  void add_index(uint16_t index) {
    fbb_.AddElement<uint16_t>(NotifyEnrollNewFinger::VT_INDEX, index, 0);
  }
  void add_step(uint8_t step) {
    fbb_.AddElement<uint8_t>(NotifyEnrollNewFinger::VT_STEP, step, 0);
  }
  void add_errorcode(uint16_t errorcode) {
    fbb_.AddElement<uint16_t>(NotifyEnrollNewFinger::VT_ERRORCODE, errorcode, 0);
  }
  explicit NotifyEnrollNewFingerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotifyEnrollNewFinger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotifyEnrollNewFinger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotifyEnrollNewFinger> CreateNotifyEnrollNewFinger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t index = 0,
    uint8_t step = 0,
    uint16_t errorcode = 0) {
  NotifyEnrollNewFingerBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_errorcode(errorcode);
  builder_.add_index(index);
  builder_.add_step(step);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NotifyEnrollNewFinger> CreateNotifyEnrollNewFingerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint16_t index = 0,
    uint8_t step = 0,
    uint16_t errorcode = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return webmanager::CreateNotifyEnrollNewFinger(
      _fbb,
      name__,
      index,
      step,
      errorcode);
}

struct NotifyFingerDetected FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotifyFingerDetectedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4,
    VT_INDEX = 6,
    VT_SCORE = 8
  };
  uint16_t errorcode() const {
    return GetField<uint16_t>(VT_ERRORCODE, 0);
  }
  uint16_t index() const {
    return GetField<uint16_t>(VT_INDEX, 0);
  }
  uint8_t score() const {
    return GetField<uint8_t>(VT_SCORE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERRORCODE, 2) &&
           VerifyField<uint16_t>(verifier, VT_INDEX, 2) &&
           VerifyField<uint8_t>(verifier, VT_SCORE, 1) &&
           verifier.EndTable();
  }
};

struct NotifyFingerDetectedBuilder {
  typedef NotifyFingerDetected Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(uint16_t errorcode) {
    fbb_.AddElement<uint16_t>(NotifyFingerDetected::VT_ERRORCODE, errorcode, 0);
  }
  void add_index(uint16_t index) {
    fbb_.AddElement<uint16_t>(NotifyFingerDetected::VT_INDEX, index, 0);
  }
  void add_score(uint8_t score) {
    fbb_.AddElement<uint8_t>(NotifyFingerDetected::VT_SCORE, score, 0);
  }
  explicit NotifyFingerDetectedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotifyFingerDetected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotifyFingerDetected>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotifyFingerDetected> CreateNotifyFingerDetected(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t errorcode = 0,
    uint16_t index = 0,
    uint8_t score = 0) {
  NotifyFingerDetectedBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_errorcode(errorcode);
  builder_.add_score(score);
  return builder_.Finish();
}

struct RequestDeleteFinger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestDeleteFingerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct RequestDeleteFingerBuilder {
  typedef RequestDeleteFinger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(RequestDeleteFinger::VT_NAME, name);
  }
  explicit RequestDeleteFingerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestDeleteFinger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestDeleteFinger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestDeleteFinger> CreateRequestDeleteFinger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  RequestDeleteFingerBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestDeleteFinger> CreateRequestDeleteFingerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return webmanager::CreateRequestDeleteFinger(
      _fbb,
      name__);
}

struct ResponseDeleteFinger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseDeleteFingerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4,
    VT_NAME = 6
  };
  uint16_t errorcode() const {
    return GetField<uint16_t>(VT_ERRORCODE, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERRORCODE, 2) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct ResponseDeleteFingerBuilder {
  typedef ResponseDeleteFinger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(uint16_t errorcode) {
    fbb_.AddElement<uint16_t>(ResponseDeleteFinger::VT_ERRORCODE, errorcode, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ResponseDeleteFinger::VT_NAME, name);
  }
  explicit ResponseDeleteFingerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseDeleteFinger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseDeleteFinger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseDeleteFinger> CreateResponseDeleteFinger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t errorcode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  ResponseDeleteFingerBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseDeleteFinger> CreateResponseDeleteFingerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t errorcode = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return webmanager::CreateResponseDeleteFinger(
      _fbb,
      errorcode,
      name__);
}

struct RequestDeleteAllFingers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestDeleteAllFingersBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestDeleteAllFingersBuilder {
  typedef RequestDeleteAllFingers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestDeleteAllFingersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestDeleteAllFingers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestDeleteAllFingers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestDeleteAllFingers> CreateRequestDeleteAllFingers(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestDeleteAllFingersBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ResponseDeleteAllFingers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseDeleteAllFingersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4
  };
  uint16_t errorcode() const {
    return GetField<uint16_t>(VT_ERRORCODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERRORCODE, 2) &&
           verifier.EndTable();
  }
};

struct ResponseDeleteAllFingersBuilder {
  typedef ResponseDeleteAllFingers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(uint16_t errorcode) {
    fbb_.AddElement<uint16_t>(ResponseDeleteAllFingers::VT_ERRORCODE, errorcode, 0);
  }
  explicit ResponseDeleteAllFingersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseDeleteAllFingers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseDeleteAllFingers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseDeleteAllFingers> CreateResponseDeleteAllFingers(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t errorcode = 0) {
  ResponseDeleteAllFingersBuilder builder_(_fbb);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

struct RequestCancelInstruction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestCancelInstructionBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestCancelInstructionBuilder {
  typedef RequestCancelInstruction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestCancelInstructionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestCancelInstruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestCancelInstruction>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestCancelInstruction> CreateRequestCancelInstruction(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestCancelInstructionBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ResponseCancelInstruction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseCancelInstructionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4
  };
  uint16_t errorcode() const {
    return GetField<uint16_t>(VT_ERRORCODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERRORCODE, 2) &&
           verifier.EndTable();
  }
};

struct ResponseCancelInstructionBuilder {
  typedef ResponseCancelInstruction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(uint16_t errorcode) {
    fbb_.AddElement<uint16_t>(ResponseCancelInstruction::VT_ERRORCODE, errorcode, 0);
  }
  explicit ResponseCancelInstructionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseCancelInstruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseCancelInstruction>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseCancelInstruction> CreateResponseCancelInstruction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t errorcode = 0) {
  ResponseCancelInstructionBuilder builder_(_fbb);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

struct RequestRenameFinger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestRenameFingerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OLD_NAME = 4,
    VT_NEW_NAME = 6
  };
  const ::flatbuffers::String *old_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OLD_NAME);
  }
  const ::flatbuffers::String *new_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NEW_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OLD_NAME) &&
           verifier.VerifyString(old_name()) &&
           VerifyOffset(verifier, VT_NEW_NAME) &&
           verifier.VerifyString(new_name()) &&
           verifier.EndTable();
  }
};

struct RequestRenameFingerBuilder {
  typedef RequestRenameFinger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_old_name(::flatbuffers::Offset<::flatbuffers::String> old_name) {
    fbb_.AddOffset(RequestRenameFinger::VT_OLD_NAME, old_name);
  }
  void add_new_name(::flatbuffers::Offset<::flatbuffers::String> new_name) {
    fbb_.AddOffset(RequestRenameFinger::VT_NEW_NAME, new_name);
  }
  explicit RequestRenameFingerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestRenameFinger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestRenameFinger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestRenameFinger> CreateRequestRenameFinger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> old_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> new_name = 0) {
  RequestRenameFingerBuilder builder_(_fbb);
  builder_.add_new_name(new_name);
  builder_.add_old_name(old_name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RequestRenameFinger> CreateRequestRenameFingerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *old_name = nullptr,
    const char *new_name = nullptr) {
  auto old_name__ = old_name ? _fbb.CreateString(old_name) : 0;
  auto new_name__ = new_name ? _fbb.CreateString(new_name) : 0;
  return webmanager::CreateRequestRenameFinger(
      _fbb,
      old_name__,
      new_name__);
}

struct ResponseRenameFinger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseRenameFingerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERRORCODE = 4
  };
  uint16_t errorcode() const {
    return GetField<uint16_t>(VT_ERRORCODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERRORCODE, 2) &&
           verifier.EndTable();
  }
};

struct ResponseRenameFingerBuilder {
  typedef ResponseRenameFinger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_errorcode(uint16_t errorcode) {
    fbb_.AddElement<uint16_t>(ResponseRenameFinger::VT_ERRORCODE, errorcode, 0);
  }
  explicit ResponseRenameFingerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseRenameFinger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseRenameFinger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseRenameFinger> CreateResponseRenameFinger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t errorcode = 0) {
  ResponseRenameFingerBuilder builder_(_fbb);
  builder_.add_errorcode(errorcode);
  return builder_.Finish();
}

struct RequestFingerprintSensorInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestFingerprintSensorInfoBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestFingerprintSensorInfoBuilder {
  typedef RequestFingerprintSensorInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestFingerprintSensorInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestFingerprintSensorInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestFingerprintSensorInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestFingerprintSensorInfo> CreateRequestFingerprintSensorInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestFingerprintSensorInfoBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ResponseFingerprintSensorInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseFingerprintSensorInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4,
    VT_LIBRARYSIZE = 6,
    VT_SECURITYLEVEL = 8,
    VT_DEVICEADDRESS = 10,
    VT_DATAPACKETSIZECODE = 12,
    VT_BAUDRATETIMES9600 = 14,
    VT_ALGVER = 16,
    VT_FWVER = 18
  };
  uint16_t status() const {
    return GetField<uint16_t>(VT_STATUS, 0);
  }
  uint16_t librarySize() const {
    return GetField<uint16_t>(VT_LIBRARYSIZE, 0);
  }
  uint8_t securityLevel() const {
    return GetField<uint8_t>(VT_SECURITYLEVEL, 0);
  }
  uint32_t deviceAddress() const {
    return GetField<uint32_t>(VT_DEVICEADDRESS, 0);
  }
  uint8_t dataPacketSizeCode() const {
    return GetField<uint8_t>(VT_DATAPACKETSIZECODE, 0);
  }
  uint8_t baudRateTimes9600() const {
    return GetField<uint8_t>(VT_BAUDRATETIMES9600, 0);
  }
  const ::flatbuffers::String *algVer() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALGVER);
  }
  const ::flatbuffers::String *fwVer() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FWVER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STATUS, 2) &&
           VerifyField<uint16_t>(verifier, VT_LIBRARYSIZE, 2) &&
           VerifyField<uint8_t>(verifier, VT_SECURITYLEVEL, 1) &&
           VerifyField<uint32_t>(verifier, VT_DEVICEADDRESS, 4) &&
           VerifyField<uint8_t>(verifier, VT_DATAPACKETSIZECODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_BAUDRATETIMES9600, 1) &&
           VerifyOffset(verifier, VT_ALGVER) &&
           verifier.VerifyString(algVer()) &&
           VerifyOffset(verifier, VT_FWVER) &&
           verifier.VerifyString(fwVer()) &&
           verifier.EndTable();
  }
};

struct ResponseFingerprintSensorInfoBuilder {
  typedef ResponseFingerprintSensorInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_status(uint16_t status) {
    fbb_.AddElement<uint16_t>(ResponseFingerprintSensorInfo::VT_STATUS, status, 0);
  }
  void add_librarySize(uint16_t librarySize) {
    fbb_.AddElement<uint16_t>(ResponseFingerprintSensorInfo::VT_LIBRARYSIZE, librarySize, 0);
  }
  void add_securityLevel(uint8_t securityLevel) {
    fbb_.AddElement<uint8_t>(ResponseFingerprintSensorInfo::VT_SECURITYLEVEL, securityLevel, 0);
  }
  void add_deviceAddress(uint32_t deviceAddress) {
    fbb_.AddElement<uint32_t>(ResponseFingerprintSensorInfo::VT_DEVICEADDRESS, deviceAddress, 0);
  }
  void add_dataPacketSizeCode(uint8_t dataPacketSizeCode) {
    fbb_.AddElement<uint8_t>(ResponseFingerprintSensorInfo::VT_DATAPACKETSIZECODE, dataPacketSizeCode, 0);
  }
  void add_baudRateTimes9600(uint8_t baudRateTimes9600) {
    fbb_.AddElement<uint8_t>(ResponseFingerprintSensorInfo::VT_BAUDRATETIMES9600, baudRateTimes9600, 0);
  }
  void add_algVer(::flatbuffers::Offset<::flatbuffers::String> algVer) {
    fbb_.AddOffset(ResponseFingerprintSensorInfo::VT_ALGVER, algVer);
  }
  void add_fwVer(::flatbuffers::Offset<::flatbuffers::String> fwVer) {
    fbb_.AddOffset(ResponseFingerprintSensorInfo::VT_FWVER, fwVer);
  }
  explicit ResponseFingerprintSensorInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseFingerprintSensorInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseFingerprintSensorInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseFingerprintSensorInfo> CreateResponseFingerprintSensorInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t status = 0,
    uint16_t librarySize = 0,
    uint8_t securityLevel = 0,
    uint32_t deviceAddress = 0,
    uint8_t dataPacketSizeCode = 0,
    uint8_t baudRateTimes9600 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> algVer = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fwVer = 0) {
  ResponseFingerprintSensorInfoBuilder builder_(_fbb);
  builder_.add_fwVer(fwVer);
  builder_.add_algVer(algVer);
  builder_.add_deviceAddress(deviceAddress);
  builder_.add_librarySize(librarySize);
  builder_.add_status(status);
  builder_.add_baudRateTimes9600(baudRateTimes9600);
  builder_.add_dataPacketSizeCode(dataPacketSizeCode);
  builder_.add_securityLevel(securityLevel);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseFingerprintSensorInfo> CreateResponseFingerprintSensorInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t status = 0,
    uint16_t librarySize = 0,
    uint8_t securityLevel = 0,
    uint32_t deviceAddress = 0,
    uint8_t dataPacketSizeCode = 0,
    uint8_t baudRateTimes9600 = 0,
    const char *algVer = nullptr,
    const char *fwVer = nullptr) {
  auto algVer__ = algVer ? _fbb.CreateString(algVer) : 0;
  auto fwVer__ = fwVer ? _fbb.CreateString(fwVer) : 0;
  return webmanager::CreateResponseFingerprintSensorInfo(
      _fbb,
      status,
      librarySize,
      securityLevel,
      deviceAddress,
      dataPacketSizeCode,
      baudRateTimes9600,
      algVer__,
      fwVer__);
}

struct RequestFingers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestFingersBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestFingersBuilder {
  typedef RequestFingers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestFingersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestFingers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestFingers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestFingers> CreateRequestFingers(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestFingersBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Finger FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FingerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INDEX = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint16_t index() const {
    return GetField<uint16_t>(VT_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_INDEX, 2) &&
           verifier.EndTable();
  }
};

struct FingerBuilder {
  typedef Finger Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Finger::VT_NAME, name);
  }
  void add_index(uint16_t index) {
    fbb_.AddElement<uint16_t>(Finger::VT_INDEX, index, 0);
  }
  explicit FingerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Finger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Finger>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Finger> CreateFinger(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint16_t index = 0) {
  FingerBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_index(index);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Finger> CreateFingerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint16_t index = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return webmanager::CreateFinger(
      _fbb,
      name__,
      index);
}

struct ResponseFingers FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseFingersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FINGERS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::Finger>> *fingers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::Finger>> *>(VT_FINGERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FINGERS) &&
           verifier.VerifyVector(fingers()) &&
           verifier.VerifyVectorOfTables(fingers()) &&
           verifier.EndTable();
  }
};

struct ResponseFingersBuilder {
  typedef ResponseFingers Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_fingers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::Finger>>> fingers) {
    fbb_.AddOffset(ResponseFingers::VT_FINGERS, fingers);
  }
  explicit ResponseFingersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseFingers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseFingers>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseFingers> CreateResponseFingers(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::Finger>>> fingers = 0) {
  ResponseFingersBuilder builder_(_fbb);
  builder_.add_fingers(fingers);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseFingers> CreateResponseFingersDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<webmanager::Finger>> *fingers = nullptr) {
  auto fingers__ = fingers ? _fbb.CreateVector<::flatbuffers::Offset<webmanager::Finger>>(*fingers) : 0;
  return webmanager::CreateResponseFingers(
      _fbb,
      fingers__);
}

struct NotifyCanMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotifyCanMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_ID = 4,
    VT_DATA = 6,
    VT_DATA_LEN = 8
  };
  uint32_t message_id() const {
    return GetField<uint32_t>(VT_MESSAGE_ID, 0);
  }
  const webmanager::CanData *data() const {
    return GetStruct<const webmanager::CanData *>(VT_DATA);
  }
  uint8_t data_len() const {
    return GetField<uint8_t>(VT_DATA_LEN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_ID, 4) &&
           VerifyField<webmanager::CanData>(verifier, VT_DATA, 1) &&
           VerifyField<uint8_t>(verifier, VT_DATA_LEN, 1) &&
           verifier.EndTable();
  }
};

struct NotifyCanMessageBuilder {
  typedef NotifyCanMessage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_id(uint32_t message_id) {
    fbb_.AddElement<uint32_t>(NotifyCanMessage::VT_MESSAGE_ID, message_id, 0);
  }
  void add_data(const webmanager::CanData *data) {
    fbb_.AddStruct(NotifyCanMessage::VT_DATA, data);
  }
  void add_data_len(uint8_t data_len) {
    fbb_.AddElement<uint8_t>(NotifyCanMessage::VT_DATA_LEN, data_len, 0);
  }
  explicit NotifyCanMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotifyCanMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotifyCanMessage>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotifyCanMessage> CreateNotifyCanMessage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t message_id = 0,
    const webmanager::CanData *data = nullptr,
    uint8_t data_len = 0) {
  NotifyCanMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message_id(message_id);
  builder_.add_data_len(data_len);
  return builder_.Finish();
}

struct RequestJournal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestJournalBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestJournalBuilder {
  typedef RequestJournal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RequestJournalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestJournal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestJournal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestJournal> CreateRequestJournal(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RequestJournalBuilder builder_(_fbb);
  return builder_.Finish();
}

struct JournalItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JournalItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LAST_MESSAGE_TIMESTAMP = 4,
    VT_MESSAGE_CODE = 6,
    VT_MESSAGE_STRING = 8,
    VT_MESSAGE_DATA = 10,
    VT_MESSAGE_COUNT = 12
  };
  uint64_t last_message_timestamp() const {
    return GetField<uint64_t>(VT_LAST_MESSAGE_TIMESTAMP, 0);
  }
  uint32_t message_code() const {
    return GetField<uint32_t>(VT_MESSAGE_CODE, 0);
  }
  const ::flatbuffers::String *message_string() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE_STRING);
  }
  uint32_t message_data() const {
    return GetField<uint32_t>(VT_MESSAGE_DATA, 0);
  }
  uint32_t message_count() const {
    return GetField<uint32_t>(VT_MESSAGE_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LAST_MESSAGE_TIMESTAMP, 8) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_CODE, 4) &&
           VerifyOffset(verifier, VT_MESSAGE_STRING) &&
           verifier.VerifyString(message_string()) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_DATA, 4) &&
           VerifyField<uint32_t>(verifier, VT_MESSAGE_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct JournalItemBuilder {
  typedef JournalItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_last_message_timestamp(uint64_t last_message_timestamp) {
    fbb_.AddElement<uint64_t>(JournalItem::VT_LAST_MESSAGE_TIMESTAMP, last_message_timestamp, 0);
  }
  void add_message_code(uint32_t message_code) {
    fbb_.AddElement<uint32_t>(JournalItem::VT_MESSAGE_CODE, message_code, 0);
  }
  void add_message_string(::flatbuffers::Offset<::flatbuffers::String> message_string) {
    fbb_.AddOffset(JournalItem::VT_MESSAGE_STRING, message_string);
  }
  void add_message_data(uint32_t message_data) {
    fbb_.AddElement<uint32_t>(JournalItem::VT_MESSAGE_DATA, message_data, 0);
  }
  void add_message_count(uint32_t message_count) {
    fbb_.AddElement<uint32_t>(JournalItem::VT_MESSAGE_COUNT, message_count, 0);
  }
  explicit JournalItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<JournalItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<JournalItem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<JournalItem> CreateJournalItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t last_message_timestamp = 0,
    uint32_t message_code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message_string = 0,
    uint32_t message_data = 0,
    uint32_t message_count = 0) {
  JournalItemBuilder builder_(_fbb);
  builder_.add_last_message_timestamp(last_message_timestamp);
  builder_.add_message_count(message_count);
  builder_.add_message_data(message_data);
  builder_.add_message_string(message_string);
  builder_.add_message_code(message_code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<JournalItem> CreateJournalItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t last_message_timestamp = 0,
    uint32_t message_code = 0,
    const char *message_string = nullptr,
    uint32_t message_data = 0,
    uint32_t message_count = 0) {
  auto message_string__ = message_string ? _fbb.CreateString(message_string) : 0;
  return webmanager::CreateJournalItem(
      _fbb,
      last_message_timestamp,
      message_code,
      message_string__,
      message_data,
      message_count);
}

struct ResponseJournal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseJournalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_JOURNAL_ITEMS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::JournalItem>> *journal_items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<webmanager::JournalItem>> *>(VT_JOURNAL_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_JOURNAL_ITEMS) &&
           verifier.VerifyVector(journal_items()) &&
           verifier.VerifyVectorOfTables(journal_items()) &&
           verifier.EndTable();
  }
};

struct ResponseJournalBuilder {
  typedef ResponseJournal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_journal_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::JournalItem>>> journal_items) {
    fbb_.AddOffset(ResponseJournal::VT_JOURNAL_ITEMS, journal_items);
  }
  explicit ResponseJournalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseJournal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseJournal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseJournal> CreateResponseJournal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<webmanager::JournalItem>>> journal_items = 0) {
  ResponseJournalBuilder builder_(_fbb);
  builder_.add_journal_items(journal_items);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ResponseJournal> CreateResponseJournalDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<webmanager::JournalItem>> *journal_items = nullptr) {
  auto journal_items__ = journal_items ? _fbb.CreateVector<::flatbuffers::Offset<webmanager::JournalItem>>(*journal_items) : 0;
  return webmanager::CreateResponseJournal(
      _fbb,
      journal_items__);
}

struct NotifyLiveLogItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotifyLiveLogItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct NotifyLiveLogItemBuilder {
  typedef NotifyLiveLogItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(NotifyLiveLogItem::VT_TEXT, text);
  }
  explicit NotifyLiveLogItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotifyLiveLogItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotifyLiveLogItem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotifyLiveLogItem> CreateNotifyLiveLogItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  NotifyLiveLogItemBuilder builder_(_fbb);
  builder_.add_text(text);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NotifyLiveLogItem> CreateNotifyLiveLogItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return webmanager::CreateNotifyLiveLogItem(
      _fbb,
      text__);
}

struct RequestWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RequestWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQUEST_TYPE = 4,
    VT_REQUEST = 6
  };
  webmanager::Requests request_type() const {
    return static_cast<webmanager::Requests>(GetField<uint8_t>(VT_REQUEST_TYPE, 0));
  }
  const void *request() const {
    return GetPointer<const void *>(VT_REQUEST);
  }
  template<typename T> const T *request_as() const;
  const websensact::CommandMessage *request_as_websensact_CommandMessage() const {
    return request_type() == webmanager::Requests_websensact_CommandMessage ? static_cast<const websensact::CommandMessage *>(request()) : nullptr;
  }
  const webmanager::RequestNetworkInformation *request_as_RequestNetworkInformation() const {
    return request_type() == webmanager::Requests_RequestNetworkInformation ? static_cast<const webmanager::RequestNetworkInformation *>(request()) : nullptr;
  }
  const webmanager::RequestWifiConnect *request_as_RequestWifiConnect() const {
    return request_type() == webmanager::Requests_RequestWifiConnect ? static_cast<const webmanager::RequestWifiConnect *>(request()) : nullptr;
  }
  const webmanager::RequestWifiDisconnect *request_as_RequestWifiDisconnect() const {
    return request_type() == webmanager::Requests_RequestWifiDisconnect ? static_cast<const webmanager::RequestWifiDisconnect *>(request()) : nullptr;
  }
  const webmanager::RequestSystemData *request_as_RequestSystemData() const {
    return request_type() == webmanager::Requests_RequestSystemData ? static_cast<const webmanager::RequestSystemData *>(request()) : nullptr;
  }
  const webmanager::RequestJournal *request_as_RequestJournal() const {
    return request_type() == webmanager::Requests_RequestJournal ? static_cast<const webmanager::RequestJournal *>(request()) : nullptr;
  }
  const webmanager::RequestRestart *request_as_RequestRestart() const {
    return request_type() == webmanager::Requests_RequestRestart ? static_cast<const webmanager::RequestRestart *>(request()) : nullptr;
  }
  const webmanager::RequestGetUserSettings *request_as_RequestGetUserSettings() const {
    return request_type() == webmanager::Requests_RequestGetUserSettings ? static_cast<const webmanager::RequestGetUserSettings *>(request()) : nullptr;
  }
  const webmanager::RequestSetUserSettings *request_as_RequestSetUserSettings() const {
    return request_type() == webmanager::Requests_RequestSetUserSettings ? static_cast<const webmanager::RequestSetUserSettings *>(request()) : nullptr;
  }
  const webmanager::RequestTimeseries *request_as_RequestTimeseries() const {
    return request_type() == webmanager::Requests_RequestTimeseries ? static_cast<const webmanager::RequestTimeseries *>(request()) : nullptr;
  }
  const webmanager::RequestOpenDoor *request_as_RequestOpenDoor() const {
    return request_type() == webmanager::Requests_RequestOpenDoor ? static_cast<const webmanager::RequestOpenDoor *>(request()) : nullptr;
  }
  const webmanager::RequestEnrollNewFinger *request_as_RequestEnrollNewFinger() const {
    return request_type() == webmanager::Requests_RequestEnrollNewFinger ? static_cast<const webmanager::RequestEnrollNewFinger *>(request()) : nullptr;
  }
  const webmanager::RequestDeleteFinger *request_as_RequestDeleteFinger() const {
    return request_type() == webmanager::Requests_RequestDeleteFinger ? static_cast<const webmanager::RequestDeleteFinger *>(request()) : nullptr;
  }
  const webmanager::RequestDeleteAllFingers *request_as_RequestDeleteAllFingers() const {
    return request_type() == webmanager::Requests_RequestDeleteAllFingers ? static_cast<const webmanager::RequestDeleteAllFingers *>(request()) : nullptr;
  }
  const webmanager::RequestRenameFinger *request_as_RequestRenameFinger() const {
    return request_type() == webmanager::Requests_RequestRenameFinger ? static_cast<const webmanager::RequestRenameFinger *>(request()) : nullptr;
  }
  const webmanager::RequestFingerprintSensorInfo *request_as_RequestFingerprintSensorInfo() const {
    return request_type() == webmanager::Requests_RequestFingerprintSensorInfo ? static_cast<const webmanager::RequestFingerprintSensorInfo *>(request()) : nullptr;
  }
  const webmanager::RequestFingers *request_as_RequestFingers() const {
    return request_type() == webmanager::Requests_RequestFingers ? static_cast<const webmanager::RequestFingers *>(request()) : nullptr;
  }
  const webmanager::RequestCancelInstruction *request_as_RequestCancelInstruction() const {
    return request_type() == webmanager::Requests_RequestCancelInstruction ? static_cast<const webmanager::RequestCancelInstruction *>(request()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQUEST_TYPE, 1) &&
           VerifyOffset(verifier, VT_REQUEST) &&
           VerifyRequests(verifier, request(), request_type()) &&
           verifier.EndTable();
  }
};

template<> inline const websensact::CommandMessage *RequestWrapper::request_as<websensact::CommandMessage>() const {
  return request_as_websensact_CommandMessage();
}

template<> inline const webmanager::RequestNetworkInformation *RequestWrapper::request_as<webmanager::RequestNetworkInformation>() const {
  return request_as_RequestNetworkInformation();
}

template<> inline const webmanager::RequestWifiConnect *RequestWrapper::request_as<webmanager::RequestWifiConnect>() const {
  return request_as_RequestWifiConnect();
}

template<> inline const webmanager::RequestWifiDisconnect *RequestWrapper::request_as<webmanager::RequestWifiDisconnect>() const {
  return request_as_RequestWifiDisconnect();
}

template<> inline const webmanager::RequestSystemData *RequestWrapper::request_as<webmanager::RequestSystemData>() const {
  return request_as_RequestSystemData();
}

template<> inline const webmanager::RequestJournal *RequestWrapper::request_as<webmanager::RequestJournal>() const {
  return request_as_RequestJournal();
}

template<> inline const webmanager::RequestRestart *RequestWrapper::request_as<webmanager::RequestRestart>() const {
  return request_as_RequestRestart();
}

template<> inline const webmanager::RequestGetUserSettings *RequestWrapper::request_as<webmanager::RequestGetUserSettings>() const {
  return request_as_RequestGetUserSettings();
}

template<> inline const webmanager::RequestSetUserSettings *RequestWrapper::request_as<webmanager::RequestSetUserSettings>() const {
  return request_as_RequestSetUserSettings();
}

template<> inline const webmanager::RequestTimeseries *RequestWrapper::request_as<webmanager::RequestTimeseries>() const {
  return request_as_RequestTimeseries();
}

template<> inline const webmanager::RequestOpenDoor *RequestWrapper::request_as<webmanager::RequestOpenDoor>() const {
  return request_as_RequestOpenDoor();
}

template<> inline const webmanager::RequestEnrollNewFinger *RequestWrapper::request_as<webmanager::RequestEnrollNewFinger>() const {
  return request_as_RequestEnrollNewFinger();
}

template<> inline const webmanager::RequestDeleteFinger *RequestWrapper::request_as<webmanager::RequestDeleteFinger>() const {
  return request_as_RequestDeleteFinger();
}

template<> inline const webmanager::RequestDeleteAllFingers *RequestWrapper::request_as<webmanager::RequestDeleteAllFingers>() const {
  return request_as_RequestDeleteAllFingers();
}

template<> inline const webmanager::RequestRenameFinger *RequestWrapper::request_as<webmanager::RequestRenameFinger>() const {
  return request_as_RequestRenameFinger();
}

template<> inline const webmanager::RequestFingerprintSensorInfo *RequestWrapper::request_as<webmanager::RequestFingerprintSensorInfo>() const {
  return request_as_RequestFingerprintSensorInfo();
}

template<> inline const webmanager::RequestFingers *RequestWrapper::request_as<webmanager::RequestFingers>() const {
  return request_as_RequestFingers();
}

template<> inline const webmanager::RequestCancelInstruction *RequestWrapper::request_as<webmanager::RequestCancelInstruction>() const {
  return request_as_RequestCancelInstruction();
}

struct RequestWrapperBuilder {
  typedef RequestWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_request_type(webmanager::Requests request_type) {
    fbb_.AddElement<uint8_t>(RequestWrapper::VT_REQUEST_TYPE, static_cast<uint8_t>(request_type), 0);
  }
  void add_request(::flatbuffers::Offset<void> request) {
    fbb_.AddOffset(RequestWrapper::VT_REQUEST, request);
  }
  explicit RequestWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RequestWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RequestWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RequestWrapper> CreateRequestWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    webmanager::Requests request_type = webmanager::Requests_NONE,
    ::flatbuffers::Offset<void> request = 0) {
  RequestWrapperBuilder builder_(_fbb);
  builder_.add_request(request);
  builder_.add_request_type(request_type);
  return builder_.Finish();
}

struct ResponseWrapper FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResponseWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESPONSE_TYPE = 4,
    VT_RESPONSE = 6
  };
  webmanager::Responses response_type() const {
    return static_cast<webmanager::Responses>(GetField<uint8_t>(VT_RESPONSE_TYPE, 0));
  }
  const void *response() const {
    return GetPointer<const void *>(VT_RESPONSE);
  }
  template<typename T> const T *response_as() const;
  const webmanager::NotifyCanMessage *response_as_NotifyCanMessage() const {
    return response_type() == webmanager::Responses_NotifyCanMessage ? static_cast<const webmanager::NotifyCanMessage *>(response()) : nullptr;
  }
  const webmanager::NotifyLiveLogItem *response_as_NotifyLiveLogItem() const {
    return response_type() == webmanager::Responses_NotifyLiveLogItem ? static_cast<const webmanager::NotifyLiveLogItem *>(response()) : nullptr;
  }
  const webmanager::ResponseNetworkInformation *response_as_ResponseNetworkInformation() const {
    return response_type() == webmanager::Responses_ResponseNetworkInformation ? static_cast<const webmanager::ResponseNetworkInformation *>(response()) : nullptr;
  }
  const webmanager::ResponseWifiConnectSuccessful *response_as_ResponseWifiConnectSuccessful() const {
    return response_type() == webmanager::Responses_ResponseWifiConnectSuccessful ? static_cast<const webmanager::ResponseWifiConnectSuccessful *>(response()) : nullptr;
  }
  const webmanager::ResponseWifiConnectFailed *response_as_ResponseWifiConnectFailed() const {
    return response_type() == webmanager::Responses_ResponseWifiConnectFailed ? static_cast<const webmanager::ResponseWifiConnectFailed *>(response()) : nullptr;
  }
  const webmanager::ResponseWifiDisconnect *response_as_ResponseWifiDisconnect() const {
    return response_type() == webmanager::Responses_ResponseWifiDisconnect ? static_cast<const webmanager::ResponseWifiDisconnect *>(response()) : nullptr;
  }
  const webmanager::ResponseSystemData *response_as_ResponseSystemData() const {
    return response_type() == webmanager::Responses_ResponseSystemData ? static_cast<const webmanager::ResponseSystemData *>(response()) : nullptr;
  }
  const webmanager::ResponseJournal *response_as_ResponseJournal() const {
    return response_type() == webmanager::Responses_ResponseJournal ? static_cast<const webmanager::ResponseJournal *>(response()) : nullptr;
  }
  const webmanager::ResponseGetUserSettings *response_as_ResponseGetUserSettings() const {
    return response_type() == webmanager::Responses_ResponseGetUserSettings ? static_cast<const webmanager::ResponseGetUserSettings *>(response()) : nullptr;
  }
  const webmanager::ResponseSetUserSettings *response_as_ResponseSetUserSettings() const {
    return response_type() == webmanager::Responses_ResponseSetUserSettings ? static_cast<const webmanager::ResponseSetUserSettings *>(response()) : nullptr;
  }
  const webmanager::ResponseTimeseriesDummy *response_as_ResponseTimeseriesDummy() const {
    return response_type() == webmanager::Responses_ResponseTimeseriesDummy ? static_cast<const webmanager::ResponseTimeseriesDummy *>(response()) : nullptr;
  }
  const webmanager::ResponseEnrollNewFinger *response_as_ResponseEnrollNewFinger() const {
    return response_type() == webmanager::Responses_ResponseEnrollNewFinger ? static_cast<const webmanager::ResponseEnrollNewFinger *>(response()) : nullptr;
  }
  const webmanager::NotifyEnrollNewFinger *response_as_NotifyEnrollNewFinger() const {
    return response_type() == webmanager::Responses_NotifyEnrollNewFinger ? static_cast<const webmanager::NotifyEnrollNewFinger *>(response()) : nullptr;
  }
  const webmanager::NotifyFingerDetected *response_as_NotifyFingerDetected() const {
    return response_type() == webmanager::Responses_NotifyFingerDetected ? static_cast<const webmanager::NotifyFingerDetected *>(response()) : nullptr;
  }
  const webmanager::ResponseDeleteFinger *response_as_ResponseDeleteFinger() const {
    return response_type() == webmanager::Responses_ResponseDeleteFinger ? static_cast<const webmanager::ResponseDeleteFinger *>(response()) : nullptr;
  }
  const webmanager::ResponseRenameFinger *response_as_ResponseRenameFinger() const {
    return response_type() == webmanager::Responses_ResponseRenameFinger ? static_cast<const webmanager::ResponseRenameFinger *>(response()) : nullptr;
  }
  const webmanager::ResponseFingerprintSensorInfo *response_as_ResponseFingerprintSensorInfo() const {
    return response_type() == webmanager::Responses_ResponseFingerprintSensorInfo ? static_cast<const webmanager::ResponseFingerprintSensorInfo *>(response()) : nullptr;
  }
  const webmanager::ResponseDeleteAllFingers *response_as_ResponseDeleteAllFingers() const {
    return response_type() == webmanager::Responses_ResponseDeleteAllFingers ? static_cast<const webmanager::ResponseDeleteAllFingers *>(response()) : nullptr;
  }
  const webmanager::ResponseFingers *response_as_ResponseFingers() const {
    return response_type() == webmanager::Responses_ResponseFingers ? static_cast<const webmanager::ResponseFingers *>(response()) : nullptr;
  }
  const webmanager::ResponseCancelInstruction *response_as_ResponseCancelInstruction() const {
    return response_type() == webmanager::Responses_ResponseCancelInstruction ? static_cast<const webmanager::ResponseCancelInstruction *>(response()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESPONSE_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESPONSE) &&
           VerifyResponses(verifier, response(), response_type()) &&
           verifier.EndTable();
  }
};

template<> inline const webmanager::NotifyCanMessage *ResponseWrapper::response_as<webmanager::NotifyCanMessage>() const {
  return response_as_NotifyCanMessage();
}

template<> inline const webmanager::NotifyLiveLogItem *ResponseWrapper::response_as<webmanager::NotifyLiveLogItem>() const {
  return response_as_NotifyLiveLogItem();
}

template<> inline const webmanager::ResponseNetworkInformation *ResponseWrapper::response_as<webmanager::ResponseNetworkInformation>() const {
  return response_as_ResponseNetworkInformation();
}

template<> inline const webmanager::ResponseWifiConnectSuccessful *ResponseWrapper::response_as<webmanager::ResponseWifiConnectSuccessful>() const {
  return response_as_ResponseWifiConnectSuccessful();
}

template<> inline const webmanager::ResponseWifiConnectFailed *ResponseWrapper::response_as<webmanager::ResponseWifiConnectFailed>() const {
  return response_as_ResponseWifiConnectFailed();
}

template<> inline const webmanager::ResponseWifiDisconnect *ResponseWrapper::response_as<webmanager::ResponseWifiDisconnect>() const {
  return response_as_ResponseWifiDisconnect();
}

template<> inline const webmanager::ResponseSystemData *ResponseWrapper::response_as<webmanager::ResponseSystemData>() const {
  return response_as_ResponseSystemData();
}

template<> inline const webmanager::ResponseJournal *ResponseWrapper::response_as<webmanager::ResponseJournal>() const {
  return response_as_ResponseJournal();
}

template<> inline const webmanager::ResponseGetUserSettings *ResponseWrapper::response_as<webmanager::ResponseGetUserSettings>() const {
  return response_as_ResponseGetUserSettings();
}

template<> inline const webmanager::ResponseSetUserSettings *ResponseWrapper::response_as<webmanager::ResponseSetUserSettings>() const {
  return response_as_ResponseSetUserSettings();
}

template<> inline const webmanager::ResponseTimeseriesDummy *ResponseWrapper::response_as<webmanager::ResponseTimeseriesDummy>() const {
  return response_as_ResponseTimeseriesDummy();
}

template<> inline const webmanager::ResponseEnrollNewFinger *ResponseWrapper::response_as<webmanager::ResponseEnrollNewFinger>() const {
  return response_as_ResponseEnrollNewFinger();
}

template<> inline const webmanager::NotifyEnrollNewFinger *ResponseWrapper::response_as<webmanager::NotifyEnrollNewFinger>() const {
  return response_as_NotifyEnrollNewFinger();
}

template<> inline const webmanager::NotifyFingerDetected *ResponseWrapper::response_as<webmanager::NotifyFingerDetected>() const {
  return response_as_NotifyFingerDetected();
}

template<> inline const webmanager::ResponseDeleteFinger *ResponseWrapper::response_as<webmanager::ResponseDeleteFinger>() const {
  return response_as_ResponseDeleteFinger();
}

template<> inline const webmanager::ResponseRenameFinger *ResponseWrapper::response_as<webmanager::ResponseRenameFinger>() const {
  return response_as_ResponseRenameFinger();
}

template<> inline const webmanager::ResponseFingerprintSensorInfo *ResponseWrapper::response_as<webmanager::ResponseFingerprintSensorInfo>() const {
  return response_as_ResponseFingerprintSensorInfo();
}

template<> inline const webmanager::ResponseDeleteAllFingers *ResponseWrapper::response_as<webmanager::ResponseDeleteAllFingers>() const {
  return response_as_ResponseDeleteAllFingers();
}

template<> inline const webmanager::ResponseFingers *ResponseWrapper::response_as<webmanager::ResponseFingers>() const {
  return response_as_ResponseFingers();
}

template<> inline const webmanager::ResponseCancelInstruction *ResponseWrapper::response_as<webmanager::ResponseCancelInstruction>() const {
  return response_as_ResponseCancelInstruction();
}

struct ResponseWrapperBuilder {
  typedef ResponseWrapper Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_response_type(webmanager::Responses response_type) {
    fbb_.AddElement<uint8_t>(ResponseWrapper::VT_RESPONSE_TYPE, static_cast<uint8_t>(response_type), 0);
  }
  void add_response(::flatbuffers::Offset<void> response) {
    fbb_.AddOffset(ResponseWrapper::VT_RESPONSE, response);
  }
  explicit ResponseWrapperBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ResponseWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ResponseWrapper>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ResponseWrapper> CreateResponseWrapper(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    webmanager::Responses response_type = webmanager::Responses_NONE,
    ::flatbuffers::Offset<void> response = 0) {
  ResponseWrapperBuilder builder_(_fbb);
  builder_.add_response(response);
  builder_.add_response_type(response_type);
  return builder_.Finish();
}

}  // namespace webmanager

namespace websensact {

}  // namespace websensact

namespace webmanager {

inline bool VerifySetting(::flatbuffers::Verifier &verifier, const void *obj, Setting type) {
  switch (type) {
    case Setting_NONE: {
      return true;
    }
    case Setting_StringSetting: {
      auto ptr = reinterpret_cast<const webmanager::StringSetting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Setting_IntegerSetting: {
      auto ptr = reinterpret_cast<const webmanager::IntegerSetting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Setting_BooleanSetting: {
      auto ptr = reinterpret_cast<const webmanager::BooleanSetting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Setting_EnumSetting: {
      auto ptr = reinterpret_cast<const webmanager::EnumSetting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySettingVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySetting(
        verifier,  values->Get(i), types->GetEnum<Setting>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyResponses(::flatbuffers::Verifier &verifier, const void *obj, Responses type) {
  switch (type) {
    case Responses_NONE: {
      return true;
    }
    case Responses_NotifyCanMessage: {
      auto ptr = reinterpret_cast<const webmanager::NotifyCanMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_NotifyLiveLogItem: {
      auto ptr = reinterpret_cast<const webmanager::NotifyLiveLogItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseNetworkInformation: {
      auto ptr = reinterpret_cast<const webmanager::ResponseNetworkInformation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseWifiConnectSuccessful: {
      auto ptr = reinterpret_cast<const webmanager::ResponseWifiConnectSuccessful *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseWifiConnectFailed: {
      auto ptr = reinterpret_cast<const webmanager::ResponseWifiConnectFailed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseWifiDisconnect: {
      auto ptr = reinterpret_cast<const webmanager::ResponseWifiDisconnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseSystemData: {
      auto ptr = reinterpret_cast<const webmanager::ResponseSystemData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseJournal: {
      auto ptr = reinterpret_cast<const webmanager::ResponseJournal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseGetUserSettings: {
      auto ptr = reinterpret_cast<const webmanager::ResponseGetUserSettings *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseSetUserSettings: {
      auto ptr = reinterpret_cast<const webmanager::ResponseSetUserSettings *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseTimeseriesDummy: {
      auto ptr = reinterpret_cast<const webmanager::ResponseTimeseriesDummy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseEnrollNewFinger: {
      auto ptr = reinterpret_cast<const webmanager::ResponseEnrollNewFinger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_NotifyEnrollNewFinger: {
      auto ptr = reinterpret_cast<const webmanager::NotifyEnrollNewFinger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_NotifyFingerDetected: {
      auto ptr = reinterpret_cast<const webmanager::NotifyFingerDetected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseDeleteFinger: {
      auto ptr = reinterpret_cast<const webmanager::ResponseDeleteFinger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseRenameFinger: {
      auto ptr = reinterpret_cast<const webmanager::ResponseRenameFinger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseFingerprintSensorInfo: {
      auto ptr = reinterpret_cast<const webmanager::ResponseFingerprintSensorInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseDeleteAllFingers: {
      auto ptr = reinterpret_cast<const webmanager::ResponseDeleteAllFingers *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseFingers: {
      auto ptr = reinterpret_cast<const webmanager::ResponseFingers *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Responses_ResponseCancelInstruction: {
      auto ptr = reinterpret_cast<const webmanager::ResponseCancelInstruction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyResponsesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyResponses(
        verifier,  values->Get(i), types->GetEnum<Responses>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyRequests(::flatbuffers::Verifier &verifier, const void *obj, Requests type) {
  switch (type) {
    case Requests_NONE: {
      return true;
    }
    case Requests_websensact_CommandMessage: {
      auto ptr = reinterpret_cast<const websensact::CommandMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestNetworkInformation: {
      auto ptr = reinterpret_cast<const webmanager::RequestNetworkInformation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestWifiConnect: {
      auto ptr = reinterpret_cast<const webmanager::RequestWifiConnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestWifiDisconnect: {
      auto ptr = reinterpret_cast<const webmanager::RequestWifiDisconnect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestSystemData: {
      auto ptr = reinterpret_cast<const webmanager::RequestSystemData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestJournal: {
      auto ptr = reinterpret_cast<const webmanager::RequestJournal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestRestart: {
      auto ptr = reinterpret_cast<const webmanager::RequestRestart *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestGetUserSettings: {
      auto ptr = reinterpret_cast<const webmanager::RequestGetUserSettings *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestSetUserSettings: {
      auto ptr = reinterpret_cast<const webmanager::RequestSetUserSettings *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestTimeseries: {
      auto ptr = reinterpret_cast<const webmanager::RequestTimeseries *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestOpenDoor: {
      auto ptr = reinterpret_cast<const webmanager::RequestOpenDoor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestEnrollNewFinger: {
      auto ptr = reinterpret_cast<const webmanager::RequestEnrollNewFinger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestDeleteFinger: {
      auto ptr = reinterpret_cast<const webmanager::RequestDeleteFinger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestDeleteAllFingers: {
      auto ptr = reinterpret_cast<const webmanager::RequestDeleteAllFingers *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestRenameFinger: {
      auto ptr = reinterpret_cast<const webmanager::RequestRenameFinger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestFingerprintSensorInfo: {
      auto ptr = reinterpret_cast<const webmanager::RequestFingerprintSensorInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestFingers: {
      auto ptr = reinterpret_cast<const webmanager::RequestFingers *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Requests_RequestCancelInstruction: {
      auto ptr = reinterpret_cast<const webmanager::RequestCancelInstruction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRequestsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRequests(
        verifier,  values->Get(i), types->GetEnum<Requests>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace webmanager

#endif  // FLATBUFFERS_GENERATED_APP_WEBMANAGER_H_
